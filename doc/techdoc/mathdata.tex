The \module{mathdata} contains the code for representing types,
terms and proofs
and the code for type checking and proof checking.
This is arguably the most important module in Qeditas.
A bug in this module could lead to non-theorems being accepted as theorems
undermining the primary purpose of the Qeditas system.
Fortunately the \file{mathdata.ml} file is not long (currently less than 2000 lines of code)
and thus can be manually audited.
We attempt to give enough information in this chapter for someone who wishes to undertake such an audit.

Much of the code in this module was taken from the code for Egal~\cite{Brown2014} system.
The main difference in the syntax is Qeditas provides explicit support for type variables.
Support for theories and signatures have also been added, and the type of documents has been modified.
Additionally, the checking functions are parameterized by functions to verify a term
identified only by its hash root has a type in a theory
and to verify a proposition identified only by its hash root is known to be a theorem in a theory.
Such information will be looked up in the ledger tree (see Chapter~\ref{chap:ctre}) by checking what is held at corresponding term addresses.

One might argue that it would be safer to use an older, established proof checker for this purpose.
However, experience has shown that even established systems can be vulnerable to ``tricks''
which can be used to prove what should be a non-theorem.
For example, on {\tt{proofmarket.org}}~\cite{ProofMarket}
a bitcoin bounty was placed on the proposition {\sf{False}} in Coq~\cite{Coq:manual}.
In spite of the fact that Coq is an advanced tool used by many people for many projects,
such a ``proof'' of {\sf{False}} was given.\footnote{In fact, two different proofs were given.}
The ``proofs'' were related to implementation issues rather than an inconsistency
in the underlying logic, but only the implementation will matter in a system like Qeditas.
By using a simple underlying logic (simple type theory)
and isolating the implementation in the reasonably small module {\module{mathdata}}
it is hoped that such apparent inconsistencies can be avoided.

The underlying logic is a form of simple type theory~\cite{Church40}
with support for prefix polymorphism.
The basic proof calculus is natural deduction~\cite{gent36,praw65}
and proof terms Curry-Howard style $\lambda$-terms~\cite{howa80}.
The logic is designed to allow for multiple theories to be
declared and for signatures to be used to import previous
typed terms and proven propositions.
Of the popular proof assistants at the moment,
the closest would probably be Isabelle~\cite{Nipkow-Paulson-Wenzel:2002},
although Isabelle follows the LCF style~\cite{GORDON79} instead of
Curry-Howard.

{\bf{Note:}} Unit tests for the {\module{mathdata}} module are in {\file{mathunittests.ml}}
in the {\file{src/unittests}}
directory in the {\branch{testing}} branch.
These unit tests give a number of examples demonstrating how the functions described below should behave.
A few examples of types, terms and proof terms used in thes unit tests are
in {\file{unittestsaux.ml}} in the same directory.
Likewise, examples of publications (encoded versions of documents released with Egal~\cite{Brown2014}) are in
{\file{testpubs1.ml}} and {\file{testpubs2.ml}} in the same directory.

{\bf{Note:}} The Coq module {\coqmod{MathData}} is intended to correspond to {\module{mathdata}},
except that the checking code is omitted and left abstract.

\section{Simple Types}

Simple types ($\alpha$, $\beta$) are described by the following grammar:
$$
\alpha,\beta ::=  \delta_n |o|\iota_n|(\alpha\to\beta)|(\Pi \alpha)
$$
We treat $\to$ as right associative to omit parentheses.
For example, $\iota_0\to\iota_0\to o$
means $(\iota_0\to (\iota_0\to o))$.
Also, we will omit parentheses in $\Pi \alpha$ since
$\Pi$ will always be used above $\to$ and so no
ambiguity can result.

Simple types are implemented as the inductive type {\type{tp}}.
We describe each constructor:
\begin{itemize}
\item ${\mbox{\constr{TpVar}}}(n)$ means the type variable $\delta_n$, where
the $n$ should be interpreted as a de Bruijn index~\cite{deBruijn72}.
For example, $\Pi \Pi \delta_1 \to \delta_0 \to \delta_1$
means the type
of a function which expects two types $\alpha$ and $\beta$,
a term of type $\alpha$, a term of type $\beta$
and returns a term of type $\alpha$.
\item {\constr{Prop}} means the type $o$ of propositions.
\item ${\mbox{\constr{Base}}}(n)$ means the $n^{th}$ base type $\iota_n$. Only finitely many base types will be explicitly used in
a theory. In fact, so far only theories using one base type
$\iota_0$ have been considered, but the support for multiple
base types is included in case it is needed later.
\item ${\mbox{\constr{TpAll}}} \alpha$ means $\Pi \alpha$, binding a type variable. Only types of the form $\Pi\cdots\Pi\alpha$
where $\alpha$ has no occurrence of a $\Pi$.
\end{itemize}

The functions {\serfunc{seo\_tp}} and {\serfunc{sei\_tp}} serialize and deserialize types.
% {\func{tp\_to\_str}} returns a string representation of the type and {\func{str\_to\_tp}} returns a type given a string representation of the type.\footnote{These are included to help with testing, and are not currently used outside {\module{mathdata}} otherwise.}

{\func{hashtp}} takes a type and returns a hash value obtained by serializing the type
to a string, hashing the string, and then hashing the result tagged with $64$.
(The intention of hashing tagged results is to ensure that, for example, the hash value
associated with a type will not accidentally be the same as the the hash value associated
with a term, proof or anything else.)

\section{Terms and Propositions}

Terms $s,t,u$ are described by the following grammar:
$$
s,t ::=  x_n |\tmh{h}|c_n|(st)|(\lambda_\alpha s)|(s\to t)|(\forall_\alpha s)|(s \alpha)|(\Lambda s)|(\tforall s)
$$
Here $n$ ranges over non-negative integers
and $h$ ranges over hash values.

Terms $x_n$ are variables,
where $n$ should be interpreted as a de Bruijn index~\cite{deBruijn72}.
For example, $\lambda_o x_0 \to \forall_o x_1\to x_0$
would be written as $\lambda y:o . y\to\forall z:o.y\to z$
in a named representation.
A term $\tmh{h}$ is an abbreviation for a term which has $h$ as its hash root (see {\func{tm\_hashroot}} below).
Note that there are two kinds of application:
(1) $(st)$ of a term $s$ to a term $t$ and
(2) $(s\alpha)$ of a term $s$ to a type $\alpha$.
Likewise there are two abstractions and two universal quantifiers:
one for the term level and one for the type level.
First, $(\lambda_\alpha s)$ is a term level abstraction representing
a function expecting an input of type $\alpha$ 
with return value determined by this input and $s$.
Likewise, $(\forall_\alpha s)$ corresponds to universally quantifying
over the elements of type $\alpha$.
On the other hand, $(\Lambda s)$ is a type level abstraction
and represents a function which expects a type $\alpha$
and then returns a value determined by $\alpha$ and $s$.
Likewise, $(\tforall s)$ corresponds to universally quantifying
over all types.
We refer to 
$\lambda_\alpha$, $\forall_\alpha$, $\Lambda$ or $\tforall$
collectively as {\defin{binders}}
and say the term $s$ in
$(\lambda_\alpha s)$, $(\forall_\alpha s)$, $(\Lambda s)$ or $(\tforall s)$
is in the {\defin{scope}} of the binder.

We often omit parentheses.
Application is assumed to be left associative
and so $s\alpha\beta t u$ means $((((s\alpha)\beta)t)u)$
If parenthesis around the body
of a binder
are omitted, then they are assumed to be such that the
scope of the binder is as large as possible.
For example, $\forall_o x_0\to x_0$ means
$(\forall_o (x_0\to x_0))$.

The corresponding type in the OCaml code is {\type{tm}}.
We describe each constructor:
\begin{itemize}
\item ${\mbox{\constr{DB}}}(n)$ corresponds to the variable $x_n$  (i.e., the de Bruijn index).
\item ${\mbox{\constr{TmH}}}(h)$ corresponds to the term $\tmh{h}$
and should be considered an abbreviation (which is sometimes opaque and sometimes transparent, depending on the current signature).
\item ${\mbox{\constr{Prim}}}(n)$ corresponds to the primitive $c_n$.
\item ${\mbox{\constr{Ap}}}(s,t)$ corresponds to term level application $st$.
\item ${\mbox{\constr{Lam}}}(\alpha,s)$ corresponds to term level abstraction $\lambda_\alpha s$.
\item ${\mbox{\constr{Imp}}}(s,t)$ corresponds to implication $s\to t$.
\item ${\mbox{\constr{All}}}(\alpha,s)$ corresponds to term level universal quantification $\forall_\alpha s$.
\item ${\mbox{\constr{TTpAp}}}(s,\alpha)$ corresponds to type level application $s\alpha$.
\item ${\mbox{\constr{TTpLam}}}(s)$ corresponds to type level abstraction $\Lambda s$
\item ${\mbox{\constr{TTpAll}}}(s)$ corresponds to type level universal quantification $\tforall s$.
\end{itemize}

The functions {\serfunc{seo\_tm}} and {\serfunc{sei\_tm}} serialize and deserialize terms.
% {\func{tm\_to\_str}} returns a string representation of the term and {\func{str\_to\_tm}} returns a term given a string representation of the type.\footnote{These are included to help with testing, and are not currently used outside {\module{mathdata}} otherwise.}

There are two functions {\func{hashtm}} 
and
{\func{tm\_hashroot}} which take terms and return
a corresponding hash value.
In the case of {\func{hashtm}},
a hash value is obtained by serializing the term
to a string, hashing the string, and then hashing the result tagged with $66$.
This (effectively) guarantees that different terms
will always be given different hash values.
On the other hand, {\func{tm\_hashroot}} takes a term and computes its {\defin{hash root}}.
The hash root of a term does not distinguish between a term
$\tmh{h}$ and a term $t$ which has $h$ as its hash root.
In effect, {\func{tm\_hashroot}} views all such abbreviations
as transparent.

The {\defin{hash root}} $\tmhr{t}$ of a term $t$ can be defined as follows:
\begin{itemize}
\item $\tmhr{\tmh{h}}$ is $h$
\item $\tmhr{c_n}$ is the hash of $n$ tagged with $96$.
\item $\tmhr{x_n}$ is the hash of $n$ tagged with $97$.
\item $\tmhr{st}$ is the hash of the hashed pair of $\tmhr{s}$ and $\tmhr{t}$ tagged with $98$.
\item $\tmhr{\lambda_\alpha s}$ is the hash of the hashed pair of the hash of $\alpha$ and $\tmhr{s}$ tagged with $99$.
\item $\tmhr{s\to t}$ is the hash of the hashed pair of $\tmhr{s}$ and $\tmhr{t}$ tagged with $100$.
\item $\tmhr{\forall_\alpha s}$ is the hash of the hashed pair of the hash of $\alpha$ and $\tmhr{s}$ tagged with $101$.
\item $\tmhr{s\alpha}$ is the hash of the hashed pair of $\tmhr{s}$ and the hash of $\alpha$ tagged with $102$.
\item $\tmhr{\Lambda s}$ is the hash of $\tmhr{s}$ tagged with $103$.
\item $\tmhr{\tforall s}$ is the hash of $\tmhr{s}$ tagged with $104$.
\end{itemize}
The reader can verify that this corresponds to the
definition of {\func{tm\_hashroot}} in the code.
The tags are used to record which term constructor was
traversed and is also used to ensure that hash roots
of terms are not the hash values computed in other contexts.

A proposition is a certain kind of term (in a given context).
In short, propositions are always of the form
$\tforall \cdots \tforall t$
where $t$ has type $o$.
Usually a proposition is simply of the form
$t$ where $t$ has type $o$.

\section{Proof Terms}

Proof terms $\cD,\cE$ are described by the following grammar:
$$
\cD,\cE ::= \gpa{h} | \hyp{n} | \known{h} | (\cD s) | (\cD \cE) | (\lambda_s \cD) | (\lambda_\alpha \cD) | (\cD \alpha) | (\Lambda \cD)
$$
Here $n$ ranges over non-negative integers
and $h$ ranges over hash values.

The proof term $\gpa{h}$
is an abbreviation for a proof term which has hash root $h$
(see {\func{pf\_hashroot}} below).
The proof term $\hyp{n}$
is the proof of a hypothesis (in a hypothesis context).
The proof term $\known{h}$
simply asserts that the proposition with hash root
$h$ is known. (The current signature maintains a list
of known propositions and their hash root.
Inclusion of such a proposition in the signature may require
checking that the term address corresponding to $h$
is owned as a proposition in the ledger. The only
way this could have happened is if the term is the axiom
of the current theory or was previously proven.)
There are three kinds of application and three kinds of abstractions.
At the proof level there are applications
$(\cD\cE)$
and abstractions
$(\lambda_s \cD)$.
These correspond to the elimination and introduction
rules for implication.
At the term level there are applications
$(\cD t)$
and abstractions
$(\lambda_\alpha\cD)$.
These correspond to the elimination and introduction
rules for universal quantification.
Finally at the type level there are applications
$(\cD\alpha)$
and abstractions
$(\Lambda\cD)$.
Type level application is the way polymorphic known propositions
are applied at specific types.
Type level abstraction is the way polymorphic propositions are
proven.

As with terms, we omit parentheses assuming application
associates to the left and
assuming abstraction (binders) have as large a scope as possible.

The corresponding type in the OCaml code is {\type{pf}}.
We describe each constructor:

The functions {\serfunc{seo\_pf}} and {\serfunc{sei\_pf}} serialize and deserialize proof terms.
% {\func{pf\_to\_str}} returns a string representation of the proof term and {\func{str\_to\_pf}} returns a proof term given a string representation of the type.\footnote{These are included to help with testing, and are not currently used outside {\module{mathdata}} otherwise.}

Again, there are two functions taking a proof term
and returning a hash value:
{\func{hashpf}}
and
{\func{pf\_hashroot}}.
The function {\func{hashpf}} takes a term and returns a hash value obtained by serializing the term
to a string, hashing the string, and then hashing the result tagged with $67$.
This implies {\func{hashpf}} returns an effectively unique hash value for each proof term.
The function {\func{pf\_hashroot}} computes a {\defin{hash root}}
similar to the way hash roots for terms are computed.
In this case, the hash root for a proof term abbreviation
$\gpa{h}$ is $h$.

\section{Publications}

There are three kinds of publications: theories, signatures and documents.
A theory declares the types of some primitives $c_n$ and gives some axioms.
A signature is to be interpreted within a given theory
and is intended to make some terms and propositions accessible for use within
another publication (a document or another signature).
A signature declares some parameters (opaque terms of the form $\tmh{h}$) giving
the hash root and the simple type,
declares some definitions
and declares some propositions to be known (either axioms of the theory or previously
proven propositions).
A document is similar to a signature except proofs of theorems are also allowed.
In addition, a document may declare a proposition to be a conjecture.

For all three kinds of publications there is a representation as a list of ``items.''
This list is perhaps best thought of as being in reverse order.
The idea is that after one has processed the ``rest'' of the list, then one
has sufficient information to process the ``head'' of the list.

In practice there is a distinction between the specification of a theory
and the theory itself. The same is true of signatures.
In essence a theory specification or signature specification corresponds to a list
of declarations, where a theory or signature itself is a ``compiled'' format which
other publications may used. This ``compiled'' format must be stored by
every node in order to check later publications. For this reasons,
Qeditas currency units must be burned in order to publish a theory or publication.
In particular, $21$ zerms must be burned for each byte in the serialized representation
of the theory or signature. The idea behind a fee of $21$ zerms is that since there
is an upper bound of $21$ million fraenks ($21$ billion zerms) we can be sure that
no more than $1$ GB worth of theories and signatures will ever be published.

\subsection{Theories}

A {\defin{theory item}} is one of the following:
\begin{itemize}
\item a declaration of a primitive to have type $\alpha$,
\item a declaration of a definition of type $\alpha$ defined by a term $s$, or
\item a declaration of proposition $s$ as an axiom.
\end{itemize}
A {\defin{theory specification}} is a list of theory items.

A {\defin{theory}} is a list of simple types $\alpha_0,\ldots,\alpha_{n-1}$
and a list of hash values $\overline{h}$.
The idea is that the primitive $c_i$ has the type $\alpha_i$ for $i<n$
and that $s$ is an axiom of the theory if $\tmhr{s}$ is in the list $\overline{h}$.

In the OCaml code the corresponding types are
{\type{theoryitem}}, {\type{theoryspec}} and
{\type{theory}}.
The type {\type{theoryitem}} has three constructors corresponding to the three cases above.
\begin{itemize}
\item $\mbox{\constr{ThyPrim}}(\alpha)$ declares that the primitive $c_n$ has type $\alpha$.
In practice $n$ is the number of {\constr{ThyPrim}} theory items in the rest of the
theory specification.
\item $\mbox{\constr{ThyDef}}(\alpha,s)$ declares that $s$ has type $\alpha$ and so $\tmh{\tmhr{s}}$ can
be used as an abbreviation.
\item $\mbox{\constr{ThyAxiom}}(t)$ declares that $t$ is a proposition and an axiom of the theory.
\end{itemize}
As usual, 
{\serfunc{seo\_theoryspec}} and {\serfunc{sei\_theoryspec}} serialize and deserialize theory specifications
while
{\serfunc{seo\_theory}} and {\serfunc{sei\_theory}} serialize and deserialize theories.

% The function
% {\func{hashtheoryspec}} takes a theory specification and returns a hash value obtained by serializing the
% theory specification to a string, hashing the string, and then hashing the result tagged with $68$.
% This effectively guarantees that different theory specifications will be given different hash values.
% This function is used to obtain a unique publication address where the publication will be
% stored in the ledger if it is published.\footnote{Shouldn't hashtheory be used for this? Otherwise
% someone could publish the same theory with two different specs. This isn't fatal, but it would mean vacuous burns and overwrites in the ttree.}

The function {\func{theoryspec\_theory}} converts a theory specification to a theory.
This is done by extracting the declared types of the first $n$ primitives (see {\func{theoryspec\_primtps}})
and by extracting the hash roots of declared axioms (see {\func{theoryspec\_hashedaxioms}}).
The pair is the intended theory. Note that declared definitions are not used to construct the theory.
Definitions in a theory may be required to check the theory specification is valid (e.g.,
to check that a term for an axiom is, in fact, a proposition).

The function {\func{hashtheory}} computes an optional hash value corresponding to a theory.
This hash value will be the identifier for the theory.
For the empty theory (no typed primitives and no axioms) the optional hash value will be {\val{None}}.
The empty theory is not explicitly stored and cannot be explicitly published.
For nonempty theories, the hash value is used to determine the $160$-bit location
where the theory is stored in the {\type{ttree}}
and the publication address where the theory specification is stored in the ledger tree.\footnote{There is actually no need to store theory publications in the ledger tree since the useful information will be in the {\type{ttree}}. However, it seems simplest to publish theory specifications as a special kind of asset created by a transaction. Such assets are stored in the ledger tree at the given address. Making an exception for theories (and signatures) would be needlessly awkward.}

The function {\func{theoryspec\_burncost}} computes the number of cants that must be burned
to publish the theory specification. It does this by computing the underlying theory with {\func{theoryspec\_theory}},
serializing the theory, taking the number of bytes of the serialization and multiplying this by
$21$ billion).

% {\func{theory\_to\_str}} returns a string representation of the theory and {\func{str\_to\_theory}} returns a theory given a string representation of the type. In this case, {\func{theory\_to\_str}} is used elsewhere in the code. In particular, the length of the string (the serialization of the theory) is used to calculate how many zerms must be burned in order to publish the theory (21 zerms must be burned for each character in the string). There is a burn fee for publishing theories since every node must keep the theory locally (in a {\type{ttree}}) in order to check documents.

\subsection{Signatures}

A {\defin{signature item}} is one of the following:
\begin{itemize}
\item a reference to another signature to import,
\item a declaration of a parameter with a given term hash root and given type,
\item a declaration of a definition with a certain type and a term which should have this type, or
\item a declaration of a proposition as known.
\end{itemize}
A {\defin{signature specification}} is a list of signature items.

A {\defin{global signature}} is a pair of lists:
\begin{itemize}
\item The first is a list of hash roots, types and optionally terms.
      That is, each element is $(h,\alpha,{\mbox{\val{None}}})$ or $(h,\alpha,s)$
      where $h$ is the term hash root of a term of type $\alpha$ (the term $s$ if it is given).
      The intention is that we know the term $\tmh{h}$ abbreviates a term of type $\alpha$.
      If $s$ is given, we also know $\tmh{h}$ can be expanded to be $s$.
\item The second is a list of hash roots and terms.
      That is, each element is $(h,s)$ where $s$ has hash root $h$
      and $s$ is either an axiom of the theory or a previously proven theorem.
      (Technically, it is $h$ that is the hash root of an axiom or previously proven theorem.
      Hence we know $s$ is equal to an axiom or previously proven theorem if all hash value
      abbreviations are expanded.)
\end{itemize}
A {\emph{signature}} is a pair of a list of hash values and a global signature.
The list of hash values is a list of references to other signatures to import.
A signature here is a certain kind of publication which allows
easy importation of previous results
and should not be confused with cryptographic signatures as discussed in Chapter~\ref{chap:cryptocurr}.
In the OCaml code we typically write {\tt{signat}} when referring to cryptographic signatures
and {\tt{signa}} when referring to the kinds of signatures as publications under consideration here.

The corresponding types in OCaml are
{\type{signaitem}} (for {\defin{signature item}}),
{\type{signaspec}} (for {\defin{signature specification}}),
{\type{gsigna}} (for {\defin{global signature}}) and
{\type{signa}} (for {\defin{signature}}).
The type {\type{sigitem}} has four constructors corresponding to the four cases above.
\begin{itemize}
\item $\mbox{\constr{SignaSigna}}(h)$ declares the importation of the signature with hash value identifier $h$.
The signature must have been previously published.
\item $\mbox{\constr{SignaParam}}(h,\alpha)$ declares that $\tmh{h}$ has type $\alpha$ and can be used
as an opaque abbreviation (a ``parameter'').
\item $\mbox{\constr{SignaDef}}(\alpha,s)$ declares that $s$ has type $\alpha$ and so $\tmh{\tmhr{s}}$ can
be used as an abbreviation.
\item $\mbox{\constr{SignaKnown}}(t)$ declares that $t$ is a proposition which is already known.
\end{itemize}
As usual,
{\serfunc{seo\_signaspec}} and {\serfunc{sei\_signaspec}} serialize and deserialize signature specifications.
{\serfunc{seo\_signa}} and {\serfunc{sei\_signa}} serialize and deserialize signatures.

The function
{\func{signaspec\_signa}}
compiles a signature specification into a signature.
The function {\func{signaspec\_signas}} computes the signatures which should be imported
by filtering out the declared signatures to import.
The function {\func{signaspec\_trms}} computes the term hash roots along with their types
and optional term definitions by filtering out the parameter and definition
declarations.
Finally, {\func{signaspec\_knowns}} computes the term hash roots and corresponding known
propositions by filtering the declared knowns and computing their hash roots.

The function {\func{hashsigna}} computes a hash value to identify the signature.
This hash value, combined with the hash value identifier of the intended theory,
is used to create both the $160$-bit location where the signature is stored
in the {\type{stree}}
and the publication address where the signature specification is stored in the ledger tree.\footnote{As with theories, there is actually no need to store signature publications in the ledger tree since the useful information will be in the {\type{stree}}. Signature specifications are stored in the ledger tree simply to
avoid having exceptional cases.}

The function {\func{signaspec\_burncost}} computes the number of cants which must
be burned
to publish the signature specification. It does this by computing the underlying signature with {\func{signaspec\_signa}},
serializing the signature, taking the number of bytes of the serialization and multiplying this by
$21$ billion).

% {\func{signa\_to\_str}} returns a string representation of the signature and {\func{str\_to\_signa}} returns a signature given a string representation of the type. As with theories, {\func{signa\_to\_str}} is used elsewhere in the code.  In particular, the length of the string (the serialization of the signature) is used to calculate how many zerms must be burned in order to publish the signature (21 zerms must be burned for each character in the string). There is a burn fee for publishing signatures since every node must keep the signature locally (in an {\type{stree}}) in order to check documents.

\subsection{Documents}

A {\defin{document item}} is one of the following:
\begin{itemize}
\item a declaration of a signature to import,
\item a declaration of a parameter with a term hash root and type,
\item a declaration of a definition with a type and a term of this type,
\item a declaration of a proposition as known,
\item a declaration of a proposition as a conjecture, or
\item a declaration of a proposition as a theorem with a proof.
\end{itemize}
A {\defin{document}} is a list of document items.

The corresponding OCaml types are {\type{docitem}} and {\type{doc}}.
The type {\type{docitem}} has six constructors corresponding to the six cases above.
\begin{itemize}
\item $\mbox{\constr{DocSigna}}(h)$ declares the importation of the signature with hash value identifier $h$.
The signature must have been previously published.
\item $\mbox{\constr{DocParam}}(h,\alpha)$ declares that $\tmh{h}$ has type $\alpha$ and can be used
as an opaque abbreviation (a ``parameter'').
\item $\mbox{\constr{DocDef}}(\alpha,s)$ declares that $s$ has type $\alpha$ and so $\tmh{\tmhr{s}}$ can
be used as an abbreviation.
\item $\mbox{\constr{DocKnown}}(t)$ declares that $t$ is a proposition which is already known.
\item $\mbox{\constr{DocConj}}(t)$ declares that $t$ is a proposition to be treated as a conjecture.
\item $\mbox{\constr{DocPfOf}}(t,\cD)$ declares that $t$ is a proposition proven by the proof term $\cD$.
\end{itemize}

As always, {\serfunc{seo\_doc}} and {\serfunc{sei\_doc}} serialize and deserialize documents.

There are two functions computing hash values for documents.
The function
{\func{hashdoc}}
computes a unique hash value for each distinct document.
This hash value is used to calculate the publication address where the document will be stored
in the ledger tree.
The function
{\func{doc\_hashroot}}
computes a hash root for a document.
This is done by combining hash roots for document items computed by {\func{docitem\_hashroot}}.

The purpose of hash roots for documents is to allow for the representation of parts
of the document in a way that still allow the hash root to be computed (as with any Merkle tree~\cite{Merkle1980}).
The type {\type{pdoc}} is the type of {\defin{partial documents}}.
Partial documents are an approximation of a document 
nodes can use for proof of storage in a block header.

The functions
{\serfunc{seo\_pdoc}} and {\serfunc{sei\_pdoc}} serialize and deserialize partial documents.

There are again two functions computing hash values.
The function {\func{hashpdoc}} computes a unique hash value for each partial document.
This is used to compute the hash of the block header in case a partial document
is used for proof of storage.
The function {\func{pdoc\_hashroot}} computes the hash root of the partial document.
If a partial document approximates a document, then both will have the same hash root.

\section{Dependency Checking}

There are a number of functions for computing the dependencies
of signatures and documents on objects and propositions.
In some cases the functions are used to check if the publisher has the
right to use the object or proposition.
In other cases the functions are used to justify the publisher claiming
ownership of an object or proposition.
Ownership of an object or proposition allows the control of the right to use
the object or proposition later.
Finally, some of the functions compute the hash values used to check the ledger
tree to see if a term with a given hash root has a given type in a given theory
or if a proposition with a given hash root is known in a given theroy.

\begin{itemize}
\item {\func{signaspec\_uses\_objs}}
\item {\func{signaspec\_uses\_props}}
\item {\func{doc\_uses\_objs}}
\item {\func{doc\_uses\_props}}
\item {\func{doc\_creates\_objs}}
\item {\func{doc\_creates\_props}}
\item {\func{doc\_creates\_neg\_props}}
\item {\func{signaspec\_stp\_markers}}
\item {\func{signaspec\_known\_markers}}
\item {\func{doc\_stp\_markers}}
\item {\func{doc\_known\_markers}}
\end{itemize}

\section{Trees of Theories and Signatures}

In order to check the correctness of a signature specification
or document, the intended theory is required.
Likewise, correctness of the new signature specification
or document depends on all signatures imported.
For this reason, each Qeditas node needs to store every theory
and every signature published so far in order to verify the correctness of
new signature specifications and documents.
Theories and signatures are stored in trees indexed by their associated
hash values. The polymorphic type {\type{htree}} in the module {\module{htree}}
provides the general infrastructure.
The two special cases are
{\type{ttree}}
and
{\type{stree}}.
A {\type{ttree}} is simply an {\type{htree}} for storing theories (elements the type {\type{theory}}).
An {\type{stree}} is an {\type{htree}} for storing signatures along with the hash value
identifier for the theory for which
the signature is intended.
Each signature is associated with a specific theory (possibly the empty theory)
and can only be imported into signature specification and documents
within the same theory.

\begin{itemize}
\item {\func{ottree\_insert}}
\item {\func{ostree\_insert}}
\item {\func{ottree\_hashroot}}
\item {\func{ostree\_hashroot}}
\item {\func{ottree\_lookup}}
\end{itemize}

\section{Type Checking and Proof Checking}

We now turn to the most important functions: those which check that a type
is valid, check that a term has a type, check that a term is a proposition,
and check that a proof term is a proof of a proposition.

All the properties defined will be relative to a
{\defin{type context}}.
Since type variables are represented
as de Bruijn indices, the {\defin{type context}}
can be taken to simply be a non-negative integer $n$.

The property of when a term has a type
depends on both a type context and a {\defin{term context}}.
A {\defin{term context}} $\Gamma$ is a list of types
$\alpha_0,\ldots,\alpha_{m-1}$
giving the types of the term level de Bruijn indices
in the current context.

The property of when a proof term is a proof of a given
proposition depends on a type context, a term context
and a {\defin{hypothesis context}}.
A {\defin{hypothesis context}} $\Phi$ is a list
$\rho_0,\ldots,\rho_{k-1}$
of terms (of type $o$ in the current type context
and term context)
giving the current assumed hypotheses
(proof level de Bruijn indices in the proof term).

\begin{itemize}
\item {\var{beta\_count}}
\item {\var{term\_count}}
\end{itemize}

\begin{itemize}
\item {\exc{CheckingFailure}}
\item {\exc{NotKnown}}
\item {\exc{UnknownTerm}}
\item {\exc{UnknownSigna}}
\item {\exc{SignaTheoryMismatch}}
\item {\exc{NonNormalTerm}}
\item {\exc{BetaLimit}}
\item {\exc{TermLimit}}
\end{itemize}

\begin{itemize}
\item {\func{check\_theoryspec}}
\item {\func{check\_signaspec}}
\item {\func{check\_doc}}
\end{itemize}
