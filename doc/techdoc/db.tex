For several data types we will need to manipulate persistent storage of values 
indexed by a hash value. (We will call this a ``database'' although 
it is only a key-value mapping.)
One way to do this would be to use a standard library built for this purpose,
such as leveldb.
However, integrating leveldb with the OCaml code has proven challenging.
Instead (at least for the moment) the database has been implemented
by simply using files in directories.
The particular implementation has been abstracted using a module type
so that the implementation of the module can be easily replaced.\footnote{Trent Russell was responsible for the initial implementation of the database code. His original implementation {\module{Dbbasic}} was modified to create {\module{Dbbasic2}} described below. The main difference is that the original {\module{Dbbasic}} implementation kept sorted index files whereas {\module{Dbbasic2}} simply appends to index files while keeping the indexing data in RAM in a hash table. The initial load of the indexing data is handled by a new function {\func{dbinit}} called at startup.}

The module type {\moduletype{dbtype}} is actually a functor type.
It depends on a signature with
\begin{itemize}
\item a type {\tt{t}} (the type of the values to be stored),
\item a string {\tt{basedir}} (indicating the top level directory where these key-value pairs will be stored) and
\item functions {\tt{seival}} and {\tt{seoval}} for deserializating and serializing the data from and to channels.
\end{itemize}
An implementation of {\moduletype{dbtype}} must implement the following:
\begin{itemize}
\item {\func{dbinit}} is intended to be called once, upon startup. It searches for all \file{index} and \file{deleted} files of the database and loads the contents into hash tables.
\item {\func{dbget}} taking a hash value (as the key) to a value of type {\tt{t}} (or raising {\exc{Not\_found}}).
\item {\func{dbexists}} takes a hash value (as the key) and returns {\val{true}} if there is an entry with this key and returns {\val{false}} otherwise. (One could use {\func{dbget}} for this purpose, but {\func{dbget}} must take the time to deserialize corresponding the value.)
\item {\func{dbput}} takes a hash value (as the key) and a value of type {\tt{t}} and stores the key-value pair.
\item {\func{dbdelete}} takes a hash value (as the key) and deletes the entry with this key, if one exists. If there is no entry, {\func{dbdelete}} does nothing.
\end{itemize}
In addition there is a module type {\moduletype{dbtypekeyiter}} which requires the implementation of an extra function {\func{dbkeyiter}}.
The function {\func{dbkeyiter}} applies a function to every key in the database.
This is used in practice to initialize headers on startup.

There is a functor {\module{Dbbasic2}} which returns
a module implementing {\moduletype{dbtype}}, given an implementation of {\tt{t}}, {\tt{basedir}}, {\tt{seival}} and {\tt{seoval}}.
The implementation of {\module{Dbbasic2}}
uses subdirectories of {\tt{basedir}}
with three files: {\file{index}},
{\file{data}}
and {\file{deleted}}.
The file {\file{data}} contains serializations of the values stored in this directory
and the file {\file{index}} contains the keys (hash values) along with integers giving
the position of the corresponding data in {\file{data}}.
The file {\file{deleted}} is a list of heys (hash values)
that have been marked as deleted (but the keys are still in {\file{index}}
and the value is still in {\file{data}}).

The maximum number of entries in the files in a directory is 65536,
but new entries are also not allowed after the {\file{data}} file
exceeds 100 MB.
After no more entries are permitted in a directory,
a subdirectory named using the next byte (in hex) of the key is
created (if necessary) and this subdirectory is used, unless it is also full.

Some auxiliary functions are used:
\begin{itemize}
\item {\func{load\_index\_to\_hashtable}} takes a hash table and a directory $d$.
Assuming an {\file{index}} file is in the directory, each entry is inserted into the hash table.
That is, for each key $k$ and integer $p$ (giving the position of the data in the {\file{data}} file
in the directory), the hash table associates the key $k$ with the directory $d$ and position $p$.
\item {\func{load\_deleted\_to\_hashtable}} takes a hash table and a directory.
Assuming a {\file{deleted}} file is in the directory, each key $k$ in the file is added to the hash table.
\item {\func{load\_deleted}} loads all the hash values (keys) in the {\file{deleted}} file of a directory.
\item {\func{undelete}} removes a key from the {\file{deleted}} file of a directory
by loading all the deleted keys and then recreating the {\file{deleted}} file without given the key.
\item {\func{count\_index}} gives the number of entries in the {\file{index}} file of a directory.
\item {\func{dbfind\_next\_space}}, {\func{dbfind\_next\_space\_a}} and {\func{dbfind\_next\_space\_b}}
are used to find the next appropriate subdirectory and position where a key
can be included.
\end{itemize}

The implementation of {\module{Dbbasic2}} works as follows:
\begin{itemize}
\item A ``mutex'' {\val{mutexdb}} is created and used with a function {\func{withlock}}
in a way that is intended to make the code thread-safe. In particular,
this should be used when reading from or writing to database files.
\item A hash table {\val{indextable}} is created to associate keys $k$ with a pair $(d,p)$
where $d$ is a string giving a directory which should contain a {\file{data}} file.
The value associated with $k$ should be contained at position $p$ in the {\file{data}} file.
\item A hash table {\val{deletedtable}} is created to remember which keys have been deleted.
(The corresponding values are not deleted from the {\file{data}} file or {\file{index}} file.
In principle they could be deleted by cleanup code offline.)
\item The functions {\func{dbinit}} and {\func{dbinit\_a}} traverse the directories under the
main database directory calling loading the contents of the {\file{index}} files
into {\val{indextable}} and the contents of the {\file{deleted}} files into
{\val{deletedtable}}.
\item {\func{dbexists}} checks if a given key is in {\val{indextable}}
and not in {\val{deletedtable}}.
\item {\func{dbget}} finds $(d,p)$ associated with $k$ in {\val{indextable}}.
If no $(d,p)$ is found, {\exc{Not\_found}} is raised.
If $k$ is in {\val{deletedtable}}, {\exc{Not\_found}} is raised.
Otherwise, the data starting at byte $p$ in the {\file{data}} file in the directory $d$
is deserialized and returned.
\item {\func{dbput}} takes a key $k$ and value $v$.
Suppose some $(d,p)$ is associated with $k$ in {\val{indextable}}.
If $k$ is in {\val{deletedtable}}, then it is removed from {\val{deletedtable}}
and the corresponding entry is removed from the {\file{deleted}} file (using {\func{undelete}}).
If $k$ is not in {\val{deletedtable}}, then simply return -- as the
key value pair already exists.
If no $(d,p)$ is associated with $k$ in {\val{indextable}},
call {\func{dbfind\_next\_space}} to find the next subdirectory
and position where the new value can be stored (which is at the end of the {\file{data}} file,
or $0$ if no {\file{data}} file yet exists).
The new entry $(k,p)$ is appended to the {\file{index}} file
and the pair $(d,p)$ is associated with $k$ in the {\val{indextable}} hash table.
The value is deserialized and appended to the end of the {\file{data}} file.
\item {\func{dbdelete}} takes a key $k$ and checks if a corresponding $(d,p)$ is in {\val{indextable}}.
If no entry is found, then do nothing.
Assume some $(d,p)$ is found.
If $k$ is in {\val{deletedtable}}, then do nothing (as it has already been deleted).
Otherwise, add $k$ to {\val{deletedtable}}
and append $k$ to the {\file{deleted}} file of the directory $d$.
\end{itemize}

There is also a module {\module{Dbbasic2keyiter}} of module type {\moduletype{dbtypekeyiter}}
implemented the same way as {\module{Dbbasic2}} except with the additional function {\func{dbkeyiter}}
which takes a function $f$ and calls it on every key in the hash table {\val{indextable}}
unless the key is in {\val{deletedtable}}.

Two simple database modules {\module{DbBlacklist}} and {\module{DbArchived}}
are defined by giving {\module{Dbbasic2}} the type {\type{bool}} and 
base directories {\dir{blacklist}} and {\dir{archived}}, respectively.
{\module{DbBlacklist}} is intended to save keys corresponding to some blacklisted data that
should not be requested from peers.
{\module{DbArchived}} is intended to save keys corresponding to old data the node no longer wishes
to store or receive.

Other instances of {\module{Dbbasic2}}
occur where the corresponding data types are defined.
For assets this is in {\module{assets}}
and
for (signed) transactions this is in {\module{tx}}
(see Chapter~\ref{chap:assetstx}).
For hcons elements and ctree elements,
giving approximations of parts of ledger trees,
this is in {\module{ctre}}
(see Chapter~\ref{chap:ctre}).
For block deltas,
this is in {\module{block}}
(see Chapter~\ref{chap:block}).
Block headers use {\module{Dbbasic2keyiter}} instead of {\module{Dbbasic2}}
so that hashes of all block headers can be processed during initialization.
The corresponding database {\module{DbBlockHeader}}
is defined in {\module{block}}
(see Chapter~\ref{chap:block}).
