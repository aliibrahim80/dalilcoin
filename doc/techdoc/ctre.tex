The {\module{ctre}} module
implements compact trees (``ctrees'')
and supporting functions.
Compact trees are used to approximate the state of the ledger
by recording what assets are held at what addresses.
The {\module{ctregraft}} module
implements a way to graft information onto a compact
tree in order to form an approximation with more information.

{\bf{Note:}} Unit tests for the {\module{ctre}} and {\module{ctregraft}} modules are in {\file{ctreunittests.ml}}
in the {\dir{src/unittests}}
directory in the {\branch{testing}} branch.
These unit tests give a number of examples demonstrating how the functions described below should behave.

\section{Compact Ledger Trees}

We describe the main content of the module {\module{ctre}}.

{\bf{Note:}} The largest part of the Coq formalization deals with verifying compact trees
indeed represent ledgers as intended.
The Coq module {\coqmod{LedgerStates}} represents ledgers as functions
describing the current state of the ledger (see the Coq type \coqtype{statefun}).
The Coq module {\coqmod{MTrees}} uses a form of Merkle tree~\cite{Merkle1980} to approximate such a
{\coqtype{statefun}} function.
The Coq types {\coqtype{hlist}} and {\coqtype{nehlist}} defined in {\coqmod{MTrees}} correspond to 
the types {\type{hlist}} and {\type{nehlist}} defined in {\module{ctre}} in the OCaml code.
The dependent Coq type {\coqtype{mtree}} $n$ is a Merkle tree with height $n$,
where the default case is $n=162$ (since Qeditas addresses are determined by 162 bits).
The Coq module {\coqmod{CTrees}} uses the compact tree (essentially a Patricia tree)
to represent the Merkle tree and hence approximate the ledger state.
The dependent Coq type {\coqtype{ctree}} $n$ is a compact tree with height $n$.
In the OCaml code the corresponding type is the simple type {\type{ctree}}.
Several functions are defined by recursion on $n$ in both the Coq and OCaml versions,
even though in the OCaml version the requirement that the compact tree has height $n$
is no longer enforced by the type system.
Note that {\coqmod{CTrees}} (mostly) corresponds to {\module{ctre}},
while {\coqmod{LedgerStates}} and {\coqmod{MTrees}} are only needed in the theory
and (for the most part) have no counterpart in the OCaml code.
For more information, see~\cite{White2015b}.

\subsection{Coin-age}

We first consider some variables which affect the likelihood of
coins to stake.\footnote{Since this has nothing to do with compact trees, it should be moved to a more appropriate module.}
The current settings have been chosen after
doing some simulations to determine a reasonable mixture
between staking of coins in the initial distribution
vs. staking of new coins issued through block rewards.
(Initial simulations revealed that block rewards could
easily dominate staking in the first few weeks unless their
influence was dampened.)

Typically, unlocked currency assets age quadratically as $(1+\lfloor\frac{a}{512}\rfloor)^2$ where $a$ is the number of blocks
since the asset became {\defin{mature}}. This continues until a maximum age is reached.
Users may commit currency assets to stake by locking them.
Locked non-reward assets mature more quickly and, once mature, have their maximum age
until it is close to the block height at which they will be unlocked, at which point
they will be ineligible for staking.
Rewards are necessarily locked. They age like unlocked currency assets until it is close to
the block height at which they will be unlocked, at which point they will be ineligible for staking.

\begin{itemize}
\item {\var{maximum\_age}} is the number of blocks after which unlocked coins
stop aging. This is currently set to $2^{14}$. With a 10 minute average block time,
this means unlocked coins reach their maximum age after roughly $4$ months.
(Coins in the initial distribution are exceptional: they have birthday $0$ and start with their maximum age.)
\item {\var{maximum\_age\_sqr}} is $(1+\lfloor \frac{a}{512}\rfloor)^2$ where $a$ is {\var{maximum\_age}}.
This is the maximum factor that can be used to determine an asset's coin-age.
Given current settings this is $33^2$, i.e., $1089$.
\item {\var{reward\_maturation}} indicates how old a reward must be before it can begin staking. This is currently set to $512$.
\item {\var{unlocked\_maturation}} indicates how many blocks must pass before
an unlocked asset can be used for staking. It is currently set to $512$.
\item {\var{locked\_maturation}} indicates how many blocks must pass before
a new locked currency asset can be used for staking.
It is currently set to $8$. This implies that $8$ blocks after creating a locked
currency asset, the currency asset can be used for staking with its maximum age,
until it is close to being unlocked.\footnote{The intention here is to encourage
stakers to commit to ``locking'' some of their coins only for use in staking.}
\item {\var{close\_to\_unlocked}} indicates the point at which locked assets can
no longer be used for staking. It is currently set to $32$, meaning that
the locked asset cannot be used for staking if it is $32$ blocks from being spendable
(or even after it is spendable).
\end{itemize}

Rewards must be locked until a certain block height before they can be spent.
In order to prevent rewards from dominating the early staking process,\footnote{If rewards could be unlocked quickly, then they could be
spent to create a locked non-reward asset. This locked non-reward asset would
very quickly mature and begin staking with its maximum age.}
this lock time is very long at first (16384 blocks, roughly 4 months), but reduces to
128 blocks (roughly 1 day) over the course of the first 114688 blocks (roughly 2 years).
The function {\var{reward\_locktime}} takes a given block height and
returns the minimum number of blocks a reward must be locked.
For the first 16384 blocks, the reward locktime is $16384$ (the same as {\var{maximum\_age}}).
Every 16384 blocks, the reward locktime is halved
until it reaches 128, where it remains indefinitely.

The function {\func{coinage}} computes the {\defin{coin-age}} of a
currency asset given the current block height.
As described above the ``age'' ranges from $0$ to $1089$,
with a quadratic increase each $512$ blocks.
(Specifically, the ``age'' progresses to be $n^2$
where $n$ is incremented from $1$ to $33$ each $512$ blocks
and then remains at $33$.)
Assume $v$ is the number of cants in the currency asset.
If the birthday of the asset is $0$, then it is part of the initial distribution
and its coin-age is $1089 v$.
Other than coins in the initial distribution,
there are three cases: unlocked currency assets, locked rewards and locked non-rewards.
Unlocked currency asset and locked rewards mature after $512$ blocks and then age quadratically
as described above. In the case of locked rewards, the coin-age drops to $0$
after block height $l-32$, where $l$ is the lock given for the reward.
Locked non-rewards mature after $8$ blocks and then have coin-age $1089 v$
until the coin-age drops to $0$ after block $l-32$, where $l$ is the lock given.

\subsection{Approximating Asset Lists by Hlists}

An asset list can be approximated by an {\defin{hlist}} $\cH$, a value of type {\type{hlist}}.
The constructors for {\type{hlist}} are as follows:
\begin{itemize}
\item ${\constr{HHash}}(h)$ approximates a nonempty asset list with hash root $h$.\footnote{The hash root of an asset list does not seem to be explicitly defined in the code. However, it could be defined using {\func{ohashlist}} and {\func{hashasset}} and this seems to be the intended hash root.}
\item ${\constr{HNil}}$ approximates the empty asset list.
\item ${\constr{HCons}}(a,\cH)$ where $a$ is an asset and $\cH$ is an hlist.
\item ${\constr{HConsH}}(h,\cH)$ where $h$ is an asset id (a hash value) and $\cH$ is an hlist.
\end{itemize}
The idea is that an hlist explicitly lists a prefix of the assets (or references to the assets
by their id) ending with a hash root
summarizing the rest of the asset list. It is also possible for the hlist to list all the assets.
Values of this type can be serialized and deserialized using
{\serfunc{seo\_hlist}}
and {\serfunc{sei\_hlist}}.

The type {\type{nehlist}} represents nonempty hlists and has three constructors:
\begin{itemize}
\item ${\constr{NehHash}}(h)$ corresponds to the hlist ${\constr{HHash}}(h)$.
\item ${\constr{NehCons}}(a,\cH)$ corresponds to the hlist ${\constr{HCons}}(a,\cH)$.
\item ${\constr{NehConsH}}(h,\cH)$ corresponds to the hlist ${\constr{HConsH}}(h,\cH)$.
\end{itemize}
Values of this type can be serialized and deserialized using
{\serfunc{seo\_nehlist}}
and
{\serfunc{sei\_nehlist}}.

We briefly relevant functions.
\begin{itemize}
\item {\func{nehlist\_hlist}} converts a nonempty hlist to an hlist.
\item {\func{hlist\_hashroot}} computes an optional hash root for an hlist, with {\val{None}} playing
the role of the hash root for {\constr{HNil}}.
\item {\func{nehlist\_hashroot}} computes a hash root for an nehlist,
the same as the one given by {\func{hlist\_hashroot}}.
\item {\func{in\_hlist}} and {\func{in\_nehlist}} check if an asset is explicitly listed in
the hlist or nehlist. Note that this will return {\val{false}} if the asset is not explicitly listed
but is an asset on the part of the list being summarized by ${\constr{HHash}}$ or ${\constr{NehHash}}$.
\item {\func{print\_hlist}} and {\func{print\_hlist\_to\_buffer}} print hlists and are included for debugging purposes.
\end{itemize}

\subsection{Compact Trees}

The intention of a compact tree is to provide a binary tree approximation of
a function from addresses (162-bit sequences) to hlists, where the hlists
approximate the assets held at the addresses.
In general, functions on compact trees will be defined by recursion and so we
usually need to consider compact trees at level $n$ (corresponding to functions
from $n$-bit sequences to hlists).
A $0$ bit corresponds to the left child while a $1$ bit corresponds to the right child.

The vast majority of the leaves will be empty, and so compact trees
only store the nonempty parts explicitly.
The empty compact tree (with no assets stored at leaves) can be thought of as
represented by {\val{None}}, and the type {\type{ctree option}}
is used when the empty compact tree should be considered.

Compact trees $\cC$ are values of type ${\type{ctree}}$, which is defined by the following constructors.
\begin{itemize}
\item ${\constr{CLeaf}}(\overline{b},\cH)$ is a compact tree with a single nonempty leaf
at the location determined by the bit sequence (list of booleans) $\overline{b}$
and containing the nonempty hlist $\cH$.
\item ${\constr{CHash}}(h)$ is a compact tree with a hash $h$. This approximates every compact tree with hash root $h$.
\item ${\constr{CLeft}}(\cC)$ is the compact tree with $\cC$ as its left child and the empty tree as its right child.
\item ${\constr{CRight}}(\cC)$ is the compact tree with the empty tree as its left child and $\cC$ as its right child.
\item ${\constr{CBin}}(\cC_0,\cC_1)$ is the compact tree with two nonempty children: $\cC_0$ on the left and $\cC_1$ on the right.
\end{itemize}
Values of type ${\type{ctree}}$ can be serialized and deserialized using
{\serfunc{seo\_ctree}}
and
{\serfunc{sei\_ctree}}.

The following functions are important:
\begin{itemize}
\item {\func{ctree\_hashroot}} computes a hash root for the compact tree.
Many different compact trees will give the same hash roots, however they will
always approximate the same ledger state.
For example, they can differ in where they include ${\constr{CHash}}$ nodes,
as well has the level of detail included in
hlists at the leaves.
\item {\func{octree\_hashroot}} takes an optional compact tree and returns an optional hash value.
It simply returns {\val{None}} for the empty compact tree {\val{None}}
and returns the result of {\func{ctree\_hashroot}} otherwise.
\item {\func{ctree\_lookup\_asset}} takes an asset id (a hash value), a ctree and a bit sequence.
It traverses to leaf in the ctree following the bit sequence.
It then tries to look up the asset with the asset id in the nonempty hlist at the leaf.
If the leaf is empty or the asset is not found, then {\val{None}} is returned. Otherwise, the asset is returned.
\item {\func{ctree\_addr}} given an address and a compact tree,
returns the leaf (as a compact tree) at that address.
This leaf could either be {\val{None}} indicating no assets are held at the address,
or it could be a nonempty hlist, approximating the assets held at the address.
It also returns the depth, which should always be 162, so it can be ignored.
\item {\func{octree\_lub}} takes the ``least upper bound'' of two optional compact trees.
These are assumed to be ``compatible'' in the sense that they must have the same hash root.
This means either both will be empty ({\val{None}})
or both will be compact trees.
The least upper bound of two empty compact trees is the empty compact tree.
For nonempty compact trees, the recursive structure is followed,
abreviations are expanded, and if one of the trees is a {\constr{CHash}}
node then the other tree is taken.
The idea is that if some information is in at least one of the trees,
then the information will be in the resulting tree.
\item {\func{print\_ctree}} and {\func{print\_ctree\_all}} print compact trees and are included for debugging purposes.
\end{itemize}

\subsection{Elements}

As noted above, the purpose of having ${\constr{CHash}}(h)$ nodes in compact trees
and having ${\constr{HHash}}(h)$ nodes in hlists
is to work with small approximations of larger structures.
We will need to save some of these small approximations as
key-value pairs in a database (see Chapter~\ref{chap:db}).
This, however, introduces a problem: many different ctrees will have hash root $h$
and can be approximated by the compact tree ${\constr{CHash}}(h)$.
If we wish to use $h$ as the key, there must be a unique compact tree (at least up to the level of detail included)
that corresponds
to $h$. A similar situation occurs when considering hlists.

To resolve these problems, we introduce a notion of {\em{elements}}
for hlists and compact trees.\footnote{The notion of an element was introduced and coded by Trent Russell in early 2016. This replaced earlier code which used ``frames'' and ``abbrev'' nodes in compact trees.}
A compact tree element will be defined so that there is at most one compact tree element with a given hash root.
We consider the case of hlists (and nehlists) first, as this is simpler.

First, empty hlists obviously do not need to be stored. It is clear that if the hashroot of an hlist is {\val{None}}, then the hlist list is {\constr{HNil}}.
Hence we only need to consider cons pairs.
We say an {\em{hcons element}} is a pair $(h,k)$ where $h$ is a hash value and $k$
is an optional hash value.
The idea is that the hlist (or nehlist) corresponds to a nonempty asset list where
the first asset has asset id $h$ and the rest of the asset list has hash root $k$ (or {\val{None}}
if there are no more assets on the list).
The weakest approximation of this asset list as an hlist
that retains the $h$ and $k$ is
${\constr{HConsH}}(h,{\constr{HHash}}(k))$ if $k$ is not ${\val{None}}$
and
${\constr{HConsH}}(h,{\constr{HNil}})$ if $k$ is not ${\val{None}}$
otherwise.
As an nehlist, the corresponding approximations are
${\constr{NehConsH}}(h,{\constr{HHash}}(k))$ if $k$ is not ${\val{None}}$
and
${\constr{NehConsH}}(h,{\constr{HNil}})$ if $k$ is not ${\val{None}}$.

The module {\module{DbHConsElt}} implements a database for storing hcons elements
(see Chapter~\ref{chap:db}).
At the moment, this uses the basic file storage implementation {\module{Dbbasic}}.

The function {\func{save\_hlist\_elements}} takes an arbitrary hlist
and splits it into elements, saving the corresponding assets in the
{\module{DbAsset}} database
and the corresponding hcons elements in the database {\module{DbHConsElt}}.
This ensures that there is enough information to reconstruct the
hlist from the hash root and the information in the database.
The function {\func{save\_nehlist\_elements}} performs a similar
function for values of type {\type{nehlist}}.

The function {\func{get\_hcons\_element}} takes a hash value and
uses {\func{dbget}} to try to look up the hcons element from the database.
If it is not found in the database,
then the data is requested from network peers\footnote{This is not currently implemented. Some earlier code to do this is commented out.}
and the exception {\exc{GettingRemoteData}} is raised.
The idea is that the next time ${\constr{get\_hcons\_element}}$ is
called the compact tree element
may have been put into the database after it was received from a peer.
The functions {\func{get\_hlist\_element}} and {\func{get\_nehlist\_element}}
call {\func{get\_hcons\_element}} and, if the hcons element is found,
returns the information packaged as a value of type {\type{hlist}} or {\type{nehlist}}.

Compact tree elements are defined to give full information for 9 levels, using
${\constr{CHash}}(h)$ at the ninth level (and using ${\constr{NehHash}}(h)$ for all leaves).
We can define this more formally as follows:
\begin{itemize}
\item A compact tree is {\em{elemental at level 0}} if it is of the form ${\constr{CHash}}(h)$.
\item A compact tree is {\em{elemental at level $i+1$}} if it is one of the following forms:
${\constr{CLeaf}}(\overline{b},{\constr{NehHash}}(h))$,
${\constr{CLeft}}(c_0)$ where $c_0$ is elemental at level $i$,
${\constr{CRight}}(c_1)$ where $c_1$ is elemental at level $i$
or
${\constr{CBin}}(c_0,c_1)$ where $c_0$ and $c_1$ is elemental at level $i$.
\item A compact tree is an {\em{element}} if it is elemental at level $9$.
\end{itemize}
The function ${\func{ctree\_element\_p}}$ checks if a compact tree is an element
and the auxiliary function ${\func{ctree\_element\_a}}$ checks if a compact
tree is elemental at level $i$.

The ${\func{ctree\_super\_element\_a}}$ checks if a compact tree has
at least as much explicit information as a compact tree that is elemental at level $i$.
Likewise, the ${\func{ctree\_super\_element\_p}}$ checks if a compact tree
has at least as much explicit information as a compact tree element.
Such compact trees can be used to extract an approximating element.
The function ${\func{super\_element\_to\_element}}$ computes such an approximation
using the function ${\func{super\_element\_to\_element\_a}}$
that computes an approximation that is elemental at a given level.

The module {\module{DbCTreeElt}} implements a database for storing compact tree elements
(see Chapter~\ref{chap:db}).
At the moment, this uses the basic file storage implementation {\module{Dbbasic}}.

The function ${\func{save\_ctree\_elements}}$
takes a compact tree and factors it into elements which are saved into
the database, returning the compact tree ${\constr{CHash}}(h)$ where $h$ is the hash root
of the compact tree.
The function makes use of ${\func{save\_ctree\_elements\_a}}$ 
which constructs intermediate elemental compact trees
and uses ${\func{dbput}}$ to save the constructed elements into the database.

The function ${\constr{get\_ctree\_element}}$ takes a hash value and
uses ${\func{dbget}}$ to try to extract the corresponding compact tree element
from the database.
If it is not found, then it is requested from peers\footnote{This is not currently implemented. Some earlier code to do this is commented out.}
and the exception ${\exc{GettingRemoteData}}$ is raised.
The idea is that the next time ${\constr{get\_ctree\_element}}$ is
called the compact tree element
may have been put into the database after it was received from a peer.

\subsection{Transactions}

We now describe functions relating compact trees and transactions.
One of the main concepts is that of {\defin{support}}.
In short, we say a compact tree supports a transaction if for each
input there is a corresponding asset held at the given address
and that a number of conditions hold.
To be more precise, there are further dependencies.
For example, some of these conditions depend on the block height
(e.g., to ensure an old enough intention justifies a publication).\footnote{Lock heights are not checked here, but instead are checked with the signatures of transactions. The reason is that lock heights prevent an asset from being spent, but do not prevent assets from being moved. The distinction between being spent and being moved is not relevant for support.}
Also, we must check the correctness of publications
which may require looking up a theory or signature.
These dependencies
are explicit in the function {\func{ctree\_supports\_tx}}
which checks if a compact tree supports a transaction,
given a block height, theory tree ({\type{ttree}}) and signature tree ({\type{stree}}).
The conditions to be checked often make reference to the actual assets
being spent (which are referred to in the transaction by their assetids).
The function {\func{ctree\_lookup\_input\_assets}} elaborates
the inputs by looking up the assets.
The exception {\exc{NotSupported}} is raised if
some condition required for a transaction to be supported fails,
which can happen either because the assets being spent cannot be found
in the compact tree or because of failure of some condition.

Let $\cC$ be a compact tree.
We say an asset $a$ is {\defin{held at $\alpha$ in $\cC$}}
if there is a nonempty hlist $\cH$ at leaf $\alpha$ in $\cC$ and $a$
is explicitly listed in $\cH$ (see {\func{in\_nehlist}}).
Let $\iota$ be an {\type{addr\_assetid}} list (a list of transaction inputs)
and $\iota'$ be a list of pairs $(\alpha,a)$ of addresses and assets.
We say $\iota'$ is an {\emph{elaboration of $\iota$ relative to $\cC$}}
if for each $(\alpha,h) \in\iota$ there is a pair $(\alpha,a) \in\iota'$
where $a$ is held at $\alpha$ in $\cC$ and $a$ has assetid $h$.\footnote{Technically, in the implementations the lists $\iota$ and $\iota'$ will list assetids and assets in the same order.}
The function {\func{ctree\_lookup\_input\_assets}} 
computes an elaboration $\iota'$ given $\iota$ and $\cC$,
raising {\exc{NotSupported}} if 
there is no asset $a$ with assetid $h$ held at $\alpha$ in $\cC$
for some $(\alpha,h)$ in $\iota$.

The function {\func{ctree\_supports\_tx}} simply
calls {\func{ctree\_lookup\_input\_assets}} to obtain $\iota'$
and then calls {\func{ctree\_supports\_tx\_2}} with this extra information.
The function {\func{ctree\_supports\_tx\_2}} checks the conditions for
$\cC$ to support $\tau=(\iota,o)$ with elaborated input $\iota'$
relative to a block height $b$, a theory tree and a signature tree.\footnote{The function {\func{ctree\_supports\_tx\_2}} is also given a list of assets, but this is simply the second components of the pairs in $\iota'$.}
Support requires several conditions.
We describe each condition as a single sentence followed by
a longer description.\footnote{Similar conditions can also be found in the Coq formalization as {\coqfunc{ctree\_supports\_tx}} in {\file{CTrees.v}}.}
\begin{enumerate}
\item {\sc{All output addresses are supported.}}
That is, for each $(\alpha,u)\in o$ there is no ${\constr{CHash}}$ node along the
path to the leaf in $\cC$ with position $\alpha$.
This is needed so that the new assets can be added to the leaves.
For each $(\alpha,u)\in o$ there are two possibilities: either there are no assets currently
held at $\alpha$
or there are assets represented by the nonempty hlist $\cH$ at $\alpha$.
If there are no assets, the new nonempty hlist will only contain the new assets.
If there are currently assets represented by $\cH$, we only need to
push the new assets onto the explicit prefix of $\cH$.
Note that this is possible even if $\cH$ is only the hash root of the hlist.
\item {\sc{If an object or a proposition is used in a signature specification, then it must be free to use.}}
For the definition of ``used'' see
{\func{output\_signaspec\_uses\_objs}}
and
{\func{output\_signaspec\_uses\_props}}.
Recall that each signature specification is intended for a specific theory (possibly the empty theory).
Each parameter in a signature specification will correspond to two term
addresses: one for the pure object and one for the object in the theory.
Both of these addresses must be owned as objects and the ownership assets
must both give $0$ as the price of a right to use the object.
Likewise each axiom in a signature specification will correspond to two term
addresses: one for the pure proposition and one for the proposition in the theory.
Both of these addresses must be owned as propositions and the ownership assets
also must give $0$ as the price of a right to use the proposition.
The reason for this condition is to prevent someone from paying once
for the right to use an object or a proposition
and then publishing it in a signature which is then free for anyone to use.
Of course, someone can purchase the ownership assets from the owners
and then make the corresponding objects and propositions free to use.
\item {\sc{If rights are spent in the input, then they must be mentioned in the output.}}
If a preasset ${\constr{RightsObj}}(\beta,n)$ is being spent, then 
$\beta$ must be ``mentioned'' (see {\func{obj\_rights\_mentioned}})
in the sense that there is either an output of the form
${\constr{RightsObj}}(\beta,m)$
or the object is used (as a parameter) in a document being published.
If a preasset ${\constr{RightsProp}}(\beta,n)$ is being spent, then 
$\beta$ must be ``mentioned'' (see {\func{prop\_rights\_mentioned}})
in the sense that there is either an output of the form
${\constr{RightsProp}}(\beta,m)$
or the proposition is used (as an axiom) in a document being published.
\item {\sc{Rights must be balanced.}}
Let $\alpha$ be a term address corresponding to an object [a proposition] used in a document.
Ensure that all the assets held at $\alpha$ are explict
(using {\func{hlist\_full\_approx}})
and look up the ownership asset for $\alpha$ as an object [a proposition].
(Such ownership assets are held at $\alpha$.)
If $\alpha$ has no owner, then the transaction is not supported.
Let $r_1$ be the number of rights to $\alpha$ used as an object [a proposition].
That is, $r_1$ is the number of documents which import $\alpha$ as a parameter [an axiom].
This is computed using {\func{count\_rights\_used}}.
Let $r_2$ be the number of rights to $\alpha$ as an object [a proposition]
which are created in the output of the transaction.
This is computed using {\func{rights\_out\_obj}} [{\func{rights\_out\_prop}}]
and can be described as a simple sum:
$$
\sum_{{\constr{RightsObj}(\alpha,m)} {\mbox{ in }} o} m
\,\,
\left[
\sum_{{\constr{RightsProp}(\alpha,m)} {\mbox{ in }} o} m
\right]
$$
Let $r_3$ be the number of rights to $\alpha$ as an object [a propostion]
which are spent in the input of the transaction.
This is computed using {\func{count\_obj\_rights}} [{\func{count\_prop\_rights}}]
and can be described as a simple sum:
$$
\sum_{{\constr{RightsObj}(\alpha,m)} {\mbox{ in }} \iota'} m
\,\,
\left[
\sum_{{\constr{RightsProp}(\alpha,m)} {\mbox{ in }} \iota'} m
\right].
$$
The function {\func{ctree\_rights\_balanced}} is called with this information,
returning a boolean indicating if the rights are {\defin{balanced}}.
Rights being balanced depends on the cost to purchase rights which is found in the
ownership asset.
If the cost to purchase rights is {\val{None}} (meaning rights cannot be purchased),
then rights are balanced if $r_1 + r_2 = r_3$.\footnote{In practice, $r_1 > 0$ since the object or proposition was used. Hence the only way this equation can hold is if $r_3>0$. This is possible if rights to use
the object or proposition were purchased earlier at a time when rights were being sold.}
If the cost to purchase rights is $0$, then the rights are balanced.\footnote{Note that this means anyone can create rights to use the object or proposition later.}
Assume the ownership asset is of the form ${\constr{OwnsObj}}(\beta,p)$
[${\constr{OwnsProp}}(\beta,p)$] where $p>0$.
That is, the cost to purchase rights is $p>0$. In this case it is possible rights are being purchased
by paying cants to $\beta$.
Let $r_4$ be the sum of cants sent to $\beta$ in the output $o$.
The rights are balanced if $r_1+r_2 = r_3+r_4$.\footnote{There is a corner case here. If the same pay address $\beta$ was used in more than one ownership asset at term addresses $\alpha_1$ and $\alpha_2$, then someone could simultaneously create rights to use $\alpha_1$ and $\alpha_2$ by paying cants to $\beta$ once in a single transaction. This can be avoided by always giving a unique pay address for distinct ownership assets. This uniqueness is not enforced.}
The transaction is not supported if the rights are not balanced.
\item {\sc{Publications are correct, new and were declared in advance by a sufficiently old intention (marker).}}
Recall that there are three kinds of publications:
theory specifications, signature specifications and documents.
The corresponding preassets are
${\constr{TheoryPublication}}(\gamma,\nu,\tau)$,
${\constr{SignaPublication}}(\gamma,\nu,h,\Sigma)$
and
${\constr{DocPublication}}(\gamma,\nu,h,\Delta)$.
Recall that $\nu$ is a nonce.
There will be two publication addresses associated with the publication.
One is determined simply by the contents ($\tau$, $(h,\Sigma)$ or $(h,\Delta)$)
and must be the $\alpha$ (in $o$) where the publication asset will be held.
(This is checked in {\func{tx\_outputs\_valid\_addr\_cats}}.)
The $\alpha$ must be empty or the transaction is not supported.
(If $\alpha$ holds an asset, it implies the publication has already been published.)
All the information (including $\gamma$ and $\nu$)
can be hashed to obtain a publication address $\beta$,
called the {\defin{marker address}}.
The author of the document was able to compute this publication address $\beta$
before making the corresponding publication (included in the preasset) public
without revealing information about the publication's contents.
The author must publish a {\constr{Marker}} asset
to the address $\beta$ a certain number of blocks before attempting to publish
the transaction with the publication.\footnote{The purpose of this is to prevent plagiarism, as described when ${\constr{Marker}}$ was introduced in Chapter~\ref{chap:assetstx}.}
The number of blocks is {\var{intention\_minage}} which is currently set to $144$ (a day, assuming 10 minute block times).
This {\constr{Marker}} must be spent by the transaction (assuring it exists)
and must be old enough, otherwise the transaction is not supported.
Finally, the publication must be correct.
Correctness is judged by {\func{check\_theoryspec}}, {\func{check\_signaspec}} or {\func{check\_doc}}.
In the cases of {\func{check\_signaspec}} or {\func{check\_doc}},
the appropriate theory (if nonempty) must be looked up in the current theory tree,
and the current signature tree must be given so that signatures imported by
the signature specification or document can be retrieved.
Also, recall that {\func{check\_signaspec}} and {\func{check\_doc}}
depend on arguments
{\var{gvtp}} and
{\var{gvkn}}
where 
{\var{gvtp}} determines if an term is known to have a type in a theory
and
{\var{gvkn}} determines if a proposition is known to be provable in a theory.
Now that we have access to the compact tree $\cC$,
we are in a position to supply these arguments.
In particular, {\var{gvtp}} computes the term address $\alpha'$ for the object in the given theory
(which depends on the theory identifier,
the hash root of the term in question and the hash of the type in question)
and uses {\func{hlist\_lookup\_obj\_owner}} to determine if $\alpha'$
is known to have an owner as an object.
Similarly, {\var{gvkn}} computes the term address $\alpha'$ for the proposition in the given theory
(which depends on the theory identifier and
the hash root of the term in question)
and uses {\func{hlist\_lookup\_prop\_owner}} to determine if $\alpha'$
is known to have an owner as a proposition.
Since term addresses can only be given owners as objects [propositions]
when they are published in a document, the type correctness [provability]
is guaranteed by ownership.
\item {\sc{If a marker asset is being spent in the input, then there must be a corresponding publication in the output.}}
Suppose $(\beta,a)\in\iota'$
where the preasset of $a$ is {\constr{Marker}}.
There must be some
${\constr{TheoryPublication}}(\gamma,\nu,\tau)$,
${\constr{SignaPublication}}(\gamma,\nu,h,\Sigma)$
or
${\constr{DocPublication}}(\gamma,\nu,h,\Delta)$
in $o$
for which $\beta$ is the marker address.
\item {\sc{If an ownership asset is spent in the input, then it must be included as an output.}}
That is, once a term address has an owner, it will always have an owner.
This is necessary since ownership is used to determine which objects have certain types and which propositions
have been proven (in both cases relative to a theory).
The ownership asset may be spent and recreated for a number of reasons.
It can be done to change the pay address or the purchase price of rights.
Such a change could correspond to the ownership being sold from one party to another,
where the payment for the sale is part of the same (atomic) transaction.
Another reason would be to collect a bounty.
Ownership of propositions and negated propositions are spent (and recreated) as part of
a transaction which collect bounties.
(Collecting bounties is the only reason for ownership of negated propositions.)
Note that the signature to spend an ownership asset is the pay address in the obligation,
not the pay address for the purchase of rights.
The pay address in the obligation indicates the ``owner'' of the term address.\footnote{Ownership assets always have nontrivial obligations.}
\item {\sc{New ownership preassets in the transaction outputs must have an explicit (non-reward) obligation and must be created or transferred. If an ownership output is being created, it must be supported by the transaction outputs.}}
Suppose $(\alpha,(\omega,u))\in o$ where $u$ is either ${\constr{OwnsObj}}(\beta,p)$,
${\constr{OwnsProp}}(\beta,p)$ or ${\constr{OwnsNegProp}}$.
The obligation $\omega$ must not be $\val{None}$ and must indicate it is not a reward.
There must either be an ownership asset at $\alpha$ listed in $\iota'$ (so ownership is being transferred)
or no ownership asset is held at $\alpha$ in $\cC$ (so the ownership is being created).
If the ownership asset is being created, then $o$ must support $u$ at $\alpha$ (see Section~\ref{sec:outputcreates}).
\item {\sc{New objects and propositions must be given ownership by the transaction publishing the document.}}
There are three different cases.
(The notions of ``creates'' used here were defined in see Section~\ref{sec:outputcreates}.)
If $o$ creates an object at term address $\alpha$
and there is no ${\constr{OwnsObj}}$ asset held at $\alpha$ in $\cC$,
then there must be some
$(\alpha,(\omega,{\constr{OwnsObj}}(\beta,p)))\in o$.
If $o$ creates a proposition at term address $\alpha$
and there is no ${\constr{OwnsProp}}$ asset held at $\alpha$ in $\cC$,
then there must be some
$(\alpha,(\omega,{\constr{OwnsProp}}(\beta,p)))\in o$.
(There is no requirement that created negated propositions must be given ownership.)
\item {\sc{Bounties can only be collected by the owners of propositions or negated propositions.}}
Suppose $(\alpha,a)\in\iota'$
and the preasset of $a$ is ${\constr{Bounty}}(v)$.
There must also be some $(\alpha,a')\in\iota'$ (with the same $\alpha$)
where the preasset of $a'$ is either ${\constr{OwnsProp}}(\beta,p)$
(for some $\beta$ and $p$)
or ${\constr{OwnsNegProp}}$.
The fact that ownership asset is being spent means that the ``owner'' (as given in the obligation of $a'$)
must have signed the transaction spending the bounty.
Note that by a condition above, the ownership asset must be recreated in the output $o$.
The idea is that an owner of the proposition or negated proposition collects
the bounty by a trivial transfer of the ownership asset.
\end{enumerate}
An attentive reader will note that none of these conditions require the currency units consumed
in the input to be at least as great as the currency units created in the outputs (plus those
required to be burned to publish theories and signatures).
This is not required for support,
and will not be true for coinstake transactions (which receive a reward).

We summarize the descriptions of these three main functions discussed above as follows:
\begin{itemize}
\item {\func{ctree\_lookup\_input\_assets}} takes a compact tree and an
{\type{addr\_assetid}} list (a list of transaction inputs)
and uses {\func{ctree\_lookup\_asset}} to look up the assets corresponding to
the assetids, returning the resulting list of pairs of addresses and assets.
If one of the assetids cannot be found in the compact tree,
the exception {\exc{NotSupported}} is raised.
\item {\func{ctree\_supports\_tx}} checks if a compact tree supports a transaction.
The function also requires an optional {\type{ttree}} (with all the currently known theories)
an optional {\type{stree}} (with all the currently known signatures)
and the current block height.
If the transaction is not supported, the exception {\exc{NotSupported}} is raised.
If the transaction is supported,
the difference between the currency units output or burned and the currency units input
is returned. If this value is negative, then it corresponds to a fee.
If the value is positive, then it corresponds to a reward.
\item {\func{ctree\_supports\_tx\_2}} is the same as {\func{ctree\_supports\_tx}}
except it also receives two extra inputs:
a list of the input addresses associated with their assets
and a list of those assets.
\end{itemize}

If a compact tree supports a transaction or list of transactions,
typically some small approximation of the compact tree also provides the support.
We next describe functions to construct such small approximations.
\begin{itemize}
\item {\func{full\_needed}} takes a {\type{addr\_preasset}} list (a list of transaction outputs)
and returns a list of bit sequences (addresses represented as boolean lists)
indicating which leaves need to have their full list of assets explicit
in order to check if the transaction with these outputs
is supported. 
\item {\func{get\_tx\_supporting\_octree}} takes a transaction and (optional) compact tree
and returns an approximation of the (optional) compact tree sufficient to support the transaction.
\item {\func{get\_txl\_supporting\_octree}} takes a list of transactions and (optional) compact tree
and returns an approximation of the (optional) compact tree sufficient to support the transactions.
\end{itemize}

There are two functions which transform (optional) compact trees using transactions.
\begin{itemize}
\item {\func{tx\_octree\_trans}} takes a block height, transaction and compact tree
and transforms the ctree by deleting assets consumed in the inputs and
create the new assets in the output. (The block height is needed to give
birthdays to the new assets.)
\item {\func{txl\_octree\_trans}} transforms a compact tree according to a
list of transactions, sequentially.
\end{itemize}

There are also four auxiliary functions exposed in the interface.
\begin{itemize}
\item {\func{strip\_bitseq\_true}} takes a list of pairs, the first component of which are bit sequences, and returns the list
filtered to the ones with a {\val{true}} as the head of the list with this {\val{true}} removed.
For example, the input
$$[((\val{false}::\overline{b_0}),x);((\val{true}::\overline{b_1}),y)]$$
would give the output
$$[(\overline{b_1},y)].$$
\item {\func{strip\_bitseq\_false}} takes a list of pairs, the first component of which are bit sequences, and returns the list
filtered to the ones with a {\val{false}} as the head of the list with this {\val{false}} removed.
For example, the input
$$[((\val{false}::\overline{b_0}),x);((\val{true}::\overline{b_1}),y)]$$
would give the output
$$[(\overline{b_0},x)].$$
\item {\func{strip\_bitseq\_true0}} takes a list of bit sequences, and returns the list
filtered to the ones with a {\val{true}} as the head of the list with this {\val{true}} removed.
\item {\func{strip\_bitseq\_false0}} takes a list of bit sequences, and returns the list
filtered to the ones with a {\val{false}} as the head of the list with this {\val{false}} removed.
\end{itemize}
These are exposed because they are used in the {\module{ctregraft}} module.\footnote{It might make more sense to combine the {\module{ctre}} and {\module{ctregraft}} modules so that these functions need not be exposed.}

\section{Grafting Trees}

The module {\module{ctregraft}}
has code for grafting subtrees onto a compact tree in order
to form an approximation with more information.
The purpose of this is so that a block header can
have a compact tree small enough to check the details of the asset which
staked the block,
and the block delta can have a graft extending this compact tree
to a larger compact tree with enough information to support
all the transactions in the block.

{\bf{Note:}} 
In the Coq formalization the Coq module {\coqmod{CTreeGrafting}}
corresponds to {\module{ctregrafting}}.
For more information, see~\cite{White2015b}.

The type {\type{cgraft}} is a list of hash values associated with compact trees.
The idea is simply to associate some hash roots with compact trees with these hash roots.
As usual, the serialization and deserialization functions
for this type are
{\serfunc{seo\_cgraft}}
and
{\serfunc{sei\_cgraft}}.

There are four functions exposed by {\module{ctregraft}}.
\begin{itemize}
\item {\func{cgraft\_valid}} checks if a graft is {\defin{valid}}, meaning simply that
each pair $(h,\cC)$ is such that the hash root of $\cC$ is $h$.
\item {\func{ctree\_cgraft}} takes a graft $\cG$ and a compact tree $\cC$
and replaces each ${\constr{CHash}}(h)$ in $\cC$ with $\cC'$
where $(h,\cC')$ is in $\cG$.
\item {\func{factor\_tx\_ctree\_cgraft}} takes a transaction and a compact tree $\cC$
and computes a pair $(\cC',\cG)$ of a compact tree $\cC'$ and a graft $\cG$.\footnote{This function is currently unused.}
Here $\cC'$ is an approximation of $\cC$
and {\func{ctree\_cgraft}} applied to $\cG$ and $\cC'$ yields $\cC$.
\item {\func{factor\_inputs\_ctree\_cgraft}} takes an {\type{addr\_assetid}}
(a list of transaction inputs)
and a compact tree $\cC$
and computes a pair $(\cC',\cG)$ of a compact tree $\cC'$ and a graft $\cG$.
Here $\cC'$ is an approximation of $\cC$
and {\func{ctree\_cgraft}} applied to $\cG$ and $\cC'$ yields $\cC$.
The purpose of this function is to factor the part of the compact tree
needed for the block header from the part needed for the rest of the block.
\end{itemize}
