The {\module{ctre}} module
implements compact trees (``ctrees'')
and supporting functions.
Compact trees are used to approximate the state of the ledger
by recording what assets are held at what addresses.
The {\module{ctregraft}} module
implements a way to graft information onto a compact
tree in order to form an approximation with more information.

{\bf{Note:}} Unit tests for the {\module{ctre}} and {\module{ctregraft}} modules are in {\file{ctreunittests.ml}}
in the {\file{src/unittests}}
directory in the {\branch{testing}} branch.
These unit tests give a number of examples demonstrating how the functions described below should behave.

\section{Compact Ledger Trees}

We describe the main content of the module {\module{ctre}}.

{\bf{Note:}} The largest part of the Coq formalization deals with verifying compact trees
indeed represent ledgers as intended.
The Coq module {\coqmod{LedgerStates}} represents ledgers as functions
describing the current state of the ledger (see the Coq type \coqtype{statefun}).
The Coq module {\coqmod{MTrees}} uses a form of Merkle tree~\cite{Merkle1980} to approximate such a
{\coqtype{statefun}} function.
The Coq types {\coqtype{hlist}} and {\coqtype{nehlist}} defined in {\coqmod{MTrees}} correspond to 
the types {\type{hlist}} and {\type{nehlist}} defined in {\module{ctre}} in the OCaml code.
The dependent Coq type {\coqtype{mtree}} $n$ is a Merkle tree with height $n$,
where the default case is $n=162$ (since Qeditas addresses are determined by 162 bits).
The Coq module {\coqmod{CTrees}} uses the compact tree (essentially a Patricia tree)
to represent the Merkle tree and hence approximate the ledger state.
The dependent Coq type {\coqtype{ctree}} $n$ is a compact tree with height $n$.
In the OCaml code the corresponding type is the simple type {\type{ctree}}.
Several functions are defined by recursion on $n$ in both the Coq and OCaml versions,
even though in the OCaml version the requirement that the compact tree has height $n$
is no longer enforced by the type system.
Note that {\coqmod{CTrees}} (mostly) corresponds to {\module{ctre}},
while {\coqmod{LedgerStates}} and {\coqmod{MTrees}} are only needed in the theory
and (for the most part) have no counterpart in the OCaml code.
Note also that frames and compact tree abbreviation nodes are not
represented in the Coq formalization as these were added later to the
OCaml code.
For more information, see~\cite{White2015b}.

\subsection{Coin-age}

We first consider some variables which affect the likelihood of
coins to stake.\footnote{Since this has nothing to do with compact trees, it should be moved to a more appropriate module.}
The current settings have been chosen after
doing some simulations to determine a reasonable mixture
between staking of coins in the initial distribution
vs. staking of new coins issued through block rewards.
(Initial simulations revealed that block rewards could
easily dominate staking in the first few weeks unless their
influence was dampened.)

Typically, unlocked currency assets age quadratically as $(1+\lfloor\frac{a}{512}\rfloor)^2$ where $a$ is the number of blocks
since the asset became {\defin{mature}}. This continues until a maximum age is reached.
Users may commit currency assets to stake by locking them.
Locked non-reward assets mature more quickly and, once mature, have their maximum age
until it is close to the block height at which they will be unlocked, at which point
they will be ineligible for staking.
Rewards are necessarily locked. They age like unlocked currency assets until it is close to
the block height at which they will be unlocked, at which point they will be ineligible for staking.

\begin{itemize}
\item {\var{maximum\_age}} is the number of blocks after which unlocked coins
stop aging. This is currently set to $2^{14}$. With a 10 minute average block time,
this means unlocked coins reach their maximum age after roughly $4$ months.
(Coins in the initial distribution are exceptional: they have birthday $0$ and start with their maximum age.)
\item {\var{maximum\_age\_sqr}} is $(1+\lfloor \frac{a}{512}\rfloor)^2$ where $a$ is {\var{maximum\_age}}.
This is the maximum factor that can be used to determine an asset's coin-age.
Given current settings this is $33^2$, i.e., $1089$.
\item {\var{reward\_maturation}} indicates how old a reward must be before it can begin staking. This is currently set to $512$.
\item {\var{reward\_locktime}} indicates the minimum number of blocks a reward must be locked.
This is currently set to $2^{14}$ (the same as {\var{maximum\_age}}).
This large value forces rewards not to be spent for roughly $4$ months.\footnote{This restriction is to dampen the effect
of rewards on staking. If rewards could be unlocked quickly, then they could be
spent to create a locked non-reward asset. This locked non-reward asset would
very quickly mature and begin staking with its maximum age.
If this setting is lowered to allow rewards to be spent more quickly,
then other values should be changed so that spending the reward to create
a locked non-reward assets cannot be used in a
way that rewards would quickly dominate the supply of actively staking coins.}
\item {\var{unlocked\_maturation}} indicates how many blocks must pass before
an unlocked asset can be used for staking. It is currently set to $512$.
\item {\var{locked\_maturation}} indicates how many blocks must pass before
a new locked currency asset can be used for staking.
It is currently set to $8$. This implies that $8$ blocks after creating a locked
currency asset, the currency asset can be used for staking with its maximum age,
until it is close to being unlocked.\footnote{The intention here is to encourage
stakers to commit to ``locking'' some of their coins only for use in staking.}
\item {\var{close\_to\_unlocked}} indicates the point at which locked assets can
no longer be used for staking. It is currently set to $32$, meaning that
the locked asset cannot be used for staking if it is $32$ blocks from being spendable
(or even after it is spendable).
\end{itemize}

The function {\func{coinage}} computes the {\defin{coin-age}} of a
currency asset given the current block height.
As described above the ``age'' ranges from $0$ to $1089$,
with a quadratic increase each $512$ blocks.
(Specifically, the ``age'' progresses to be $n^2$
where $n$ is incremented from $1$ to $33$ each $512$ blocks
and then remains at $33$.)
Assume $v$ is the number of cants in the currency asset.
If the birthday of the asset is $0$, then it is part of the initial distribution
and its coin-age is $1089 v$.
Other than coins in the initial distribution,
there are three cases: unlocked currency assets, locked rewards and locked non-rewards.
Unlocked currency asset and locked rewards mature after $512$ blocks and then age quadratically
as described above. In the case of locked rewards, the coin-age drops to $0$
after block height $l-32$, where $l$ is the lock given for the reward.
Locked non-rewards mature after $8$ blocks and then have coin-age $1089 v$
until the coin-age drops to $0$ after block $l-32$, where $l$ is the lock given.

\subsection{Approximating Asset Lists by Hlists}

\begin{itemize}
\item {\type{hlist}}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_hlist}}
and {\serfunc{sei\_hlist}}.
\item {\type{nehlist}}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_nehlist}}
and
{\serfunc{sei\_nehlist}}.
\item {\type{frame}}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_frame}}
and
{\serfunc{sei\_frame}}.
\item {\type{rframe}}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_rframe}}
and
{\serfunc{sei\_rframe}}.
\item {\type{ctree}}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_ctree}}
and
{\serfunc{sei\_ctree}}.
\end{itemize}

\begin{itemize}
\item {\var{localframe}}
\item {\var{localframehash}}
\end{itemize}

{\exc{NotSupported}}

\begin{itemize}
\item {\func{hlist\_hashroot}}
\item {\func{nehlist\_hlist}}
\item {\func{nehlist\_hashroot}}
\item {\func{normalize\_frame}}
\item {\func{rframe\_lub}}
\item {\func{hashctree}}
\item {\func{ctree\_hashroot}}
\item {\func{octree\_hashroot}}
\item {\func{ctree\_lookup\_asset}}
\item {\func{remove\_hashed\_ctree}}
\item {\func{archive\_unused\_ctrees}}
\item {\func{remove\_unused\_ctrees}}
\item {\func{ctree\_pre}}
\item {\func{ctree\_addr}}
\item {\func{frame\_filter\_ctree}}
\item {\func{frame\_filter\_octree}}
\item {\func{rframe\_filter\_ctree}}
\item {\func{rframe\_filter\_octree}}
\item {\func{lookup\_all\_ctree\_root\_abbrevs}}
\item {\func{lookup\_frame\_ctree\_root\_abbrev}}
\item {\func{get\_ctree\_abbrev}}
\item {\func{load\_root\_abbrevs\_index}}
\item {\func{strip\_bitseq\_true}}
\item {\func{strip\_bitseq\_false}}
\item {\func{strip\_bitseq\_true0}}
\item {\func{strip\_bitseq\_false0}}
\item {\func{ctree\_lookup\_input\_assets}}
\item {\func{ctree\_supports\_tx}}
\item {\func{ctree\_supports\_tx\_2}}
\item {\func{tx\_octree\_trans}}
\item {\func{txl\_octree\_trans}}
\item {\func{octree\_lub}}
\item {\func{full\_needed}}
\item {\func{get\_tx\_supporting\_octree}}
\item {\func{get\_txl\_supporting\_octree}}
\item {\func{print\_hlist}}
\item {\func{print\_hlist\_to\_buffer}}
\item {\func{print\_ctree}}
\item {\func{print\_ctree\_all}}
\item {\func{wrap\_frame}}
\item {\func{hashframe}}
\item {\func{frame\_add\_leaf}}
\item {\func{frame\_set\_hash\_pos}}
\item {\func{frame\_set\_abbrev\_pos}}
\item {\func{frame\_set\_abbrev\_level}}
\item {\func{frame\_set\_all\_pos}}
\item {\func{build\_rframe\_to\_req}}
\item {\func{split\_rframe\_for\_reqs}}
\end{itemize}

\section{Grafting Trees}

\module{ctregraft}

{\bf{Note:}} 
In the Coq formalization the Coq module {\coqmod{CTreeGrafting}}
corresponds to {\module{ctregrafting}}.
For more information, see~\cite{White2015b}.

{\type{cgraft}}
with serialization function
{\serfunc{seo\_cgraft}}
and deerialization function
{\serfunc{sei\_cgraft}}.

\begin{itemize}
\item {\func{cgraft\_valid}}
\item {\func{ctree\_cgraft}}
\item {\func{factor\_tx\_ctree\_cgraft}}
\item {\func{factor\_inputs\_ctree\_cgraft}}
\end{itemize}
