The {\module{ctre}} module
implements compact trees (``ctrees'')
and supporting functions.
Compact trees are used to approximate the state of the ledger
by recording what assets are held at what addresses.
The {\module{ctregraft}} module
implements a way to graft information onto a compact
tree in order to form an approximation with more information.

{\bf{Note:}} Unit tests for the {\module{ctre}} and {\module{ctregraft}} modules are in {\file{ctreunittests.ml}}
in the {\file{src/unittests}}
directory in the {\branch{testing}} branch.
These unit tests give a number of examples demonstrating how the functions described below should behave.

\section{Compact Ledger Trees}

We describe the main content of the module {\module{ctre}}.

{\bf{Note:}} The largest part of the Coq formalization deals with verifying compact trees
indeed represent ledgers as intended.
The Coq module {\coqmod{LedgerStates}} represents ledgers as functions
describing the current state of the ledger (see the Coq type \coqtype{statefun}).
The Coq module {\coqmod{MTrees}} uses a form of Merkle tree~\cite{Merkle1980} to approximate such a
{\coqtype{statefun}} function.
The Coq types {\coqtype{hlist}} and {\coqtype{nehlist}} defined in {\coqmod{MTrees}} correspond to 
the types {\type{hlist}} and {\type{nehlist}} defined in {\module{ctre}} in the OCaml code.
The dependent Coq type {\coqtype{mtree}} $n$ is a Merkle tree with height $n$,
where the default case is $n=162$ (since Qeditas addresses are determined by 162 bits).
The Coq module {\coqmod{CTrees}} uses the compact tree (essentially a Patricia tree)
to represent the Merkle tree and hence approximate the ledger state.
The dependent Coq type {\coqtype{ctree}} $n$ is a compact tree with height $n$.
In the OCaml code the corresponding type is the simple type {\type{ctree}}.
Several functions are defined by recursion on $n$ in both the Coq and OCaml versions,
even though in the OCaml version the requirement that the compact tree has height $n$
is no longer enforced by the type system.
Note that {\coqmod{CTrees}} (mostly) corresponds to {\module{ctre}},
while {\coqmod{LedgerStates}} and {\coqmod{MTrees}} are only needed in the theory
and (for the most part) have no counterpart in the OCaml code.
Note also that frames and compact tree abbreviation nodes are not
represented in the Coq formalization as these were added later to the
OCaml code.
For more information, see~\cite{White2015b}.

\subsection{Coin-age}

We first consider some variables which affect the likelihood of
coins to stake.\footnote{Since this has nothing to do with compact trees, it should be moved to a more appropriate module.}
The current settings have been chosen after
doing some simulations to determine a reasonable mixture
between staking of coins in the initial distribution
vs. staking of new coins issued through block rewards.
(Initial simulations revealed that block rewards could
easily dominate staking in the first few weeks unless their
influence was dampened.)

Typically, unlocked currency assets age quadratically as $(1+\lfloor\frac{a}{512}\rfloor)^2$ where $a$ is the number of blocks
since the asset became {\defin{mature}}. This continues until a maximum age is reached.
Users may commit currency assets to stake by locking them.
Locked non-reward assets mature more quickly and, once mature, have their maximum age
until it is close to the block height at which they will be unlocked, at which point
they will be ineligible for staking.
Rewards are necessarily locked. They age like unlocked currency assets until it is close to
the block height at which they will be unlocked, at which point they will be ineligible for staking.

\begin{itemize}
\item {\var{maximum\_age}} is the number of blocks after which unlocked coins
stop aging. This is currently set to $2^{14}$. With a 10 minute average block time,
this means unlocked coins reach their maximum age after roughly $4$ months.
(Coins in the initial distribution are exceptional: they have birthday $0$ and start with their maximum age.)
\item {\var{maximum\_age\_sqr}} is $(1+\lfloor \frac{a}{512}\rfloor)^2$ where $a$ is {\var{maximum\_age}}.
This is the maximum factor that can be used to determine an asset's coin-age.
Given current settings this is $33^2$, i.e., $1089$.
\item {\var{reward\_maturation}} indicates how old a reward must be before it can begin staking. This is currently set to $512$.
\item {\var{unlocked\_maturation}} indicates how many blocks must pass before
an unlocked asset can be used for staking. It is currently set to $512$.
\item {\var{locked\_maturation}} indicates how many blocks must pass before
a new locked currency asset can be used for staking.
It is currently set to $8$. This implies that $8$ blocks after creating a locked
currency asset, the currency asset can be used for staking with its maximum age,
until it is close to being unlocked.\footnote{The intention here is to encourage
stakers to commit to ``locking'' some of their coins only for use in staking.}
\item {\var{close\_to\_unlocked}} indicates the point at which locked assets can
no longer be used for staking. It is currently set to $32$, meaning that
the locked asset cannot be used for staking if it is $32$ blocks from being spendable
(or even after it is spendable).
\end{itemize}

Rewards must be locked until a certain block height before they can be spent.
In order to prevent rewards from dominating the early staking process,\footnote{If rewards could be unlocked quickly, then they could be
spent to create a locked non-reward asset. This locked non-reward asset would
very quickly mature and begin staking with its maximum age.}
this lock time is very long at first (16384 blocks, roughly 4 months), but reduces to
128 blocks (roughly 1 day) over the course of the first 114688 blocks (roughly 2 years).
The function {\var{reward\_locktime}} takes a given block height and
returns the minimum number of blocks a reward must be locked.
For the first 16834 blocks, the reward locktime is $16384$ (the same as {\var{maximum\_age}}).
Every 16384 blocks, the reward locktime is halved
until it reaches 128, where it remains indefinitely.

The function {\func{coinage}} computes the {\defin{coin-age}} of a
currency asset given the current block height.
As described above the ``age'' ranges from $0$ to $1089$,
with a quadratic increase each $512$ blocks.
(Specifically, the ``age'' progresses to be $n^2$
where $n$ is incremented from $1$ to $33$ each $512$ blocks
and then remains at $33$.)
Assume $v$ is the number of cants in the currency asset.
If the birthday of the asset is $0$, then it is part of the initial distribution
and its coin-age is $1089 v$.
Other than coins in the initial distribution,
there are three cases: unlocked currency assets, locked rewards and locked non-rewards.
Unlocked currency asset and locked rewards mature after $512$ blocks and then age quadratically
as described above. In the case of locked rewards, the coin-age drops to $0$
after block height $l-32$, where $l$ is the lock given for the reward.
Locked non-rewards mature after $8$ blocks and then have coin-age $1089 v$
until the coin-age drops to $0$ after block $l-32$, where $l$ is the lock given.

\subsection{Approximating Asset Lists by Hlists}

An asset list can be approximated by an {\defin{hlist}} $\cH$, a value of type {\type{hlist}}.
The constructors for {\type{hlist}} are as follows:
\begin{itemize}
\item ${\constr{HHash}}(h)$ approximates a nonempty asset list with hash root $h$.\footnote{The hash root of an asset list does not seem to be explicitly defined in the code. However, it could be defined using {\func{ohashlist}} and {\func{hashasset}} and this seems to be the intended hash root.}
\item ${\constr{HNil}}$ approximates the empty asset list.
\item ${\constr{HCons}}(a,\cH)$ where $a$ is an asset and $\cH$ is an hlist.
\end{itemize}
The idea is that an hlist explicit lists a prefix of the assets ending with a hash root
summarizing the rest of the asset list. It is also possible for the hlist to list all the assets.
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_hlist}}
and {\serfunc{sei\_hlist}}.

The type {\type{nehlist}} represents nonempty hlists and has two constructors:
\begin{itemize}
\item ${\constr{NehHash}}(h)$ corresponds to the hlist ${\constr{HHash}}(h)$.
\item ${\constr{NehCons}}(a,\cH)$ corresponds to the hlist ${\constr{HCons}}(a,\cH)$.
\end{itemize}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_nehlist}}
and
{\serfunc{sei\_nehlist}}.

We briefly relevant functions.
\begin{itemize}
\item {\func{nehlist\_hlist}} converts a nonempty hlist to an hlist.
\item {\func{hlist\_hashroot}} computes an optional hash root for an hlist, with {\val{None}} playing
the role of the hash root for {\constr{HNil}}.
\item {\func{nehlist\_hashroot}} computes a hash root for an nehlist,
the same as the one given by {\func{hlist\_hashroot}}.
\item {\func{in\_hlist}} and {\func{in\_nehlist}} check if an asset is explicitly listed in
the hlist or nehlist. Note that this will return {\val{false}} if the asset is not explicitly listed
but is an asset on the part of the list being summarized by ${\constr{HHash}}$ or ${\constr{NehHash}}$.
\item {\func{print\_hlist}} and {\func{print\_hlist\_to\_buffer}} print hlists and are included for debugging purposes.
\end{itemize}

\subsection{Compact Trees}

The intention of a compact tree is to provide a binary tree approximation of
a function from addresses (162-bit sequences) to hlists, where the hlists
approximate the assets held at the addresses.
In general, functions on compact trees will be defined by recursion and so we
usually need to consider compact trees at level $n$ (corresponding to functions
from $n$-bit sequences to hlists).
A $0$ bit corresponds to the left child while a $1$ bit corresponds to the right child.

The vast majority of the leaves will be empty, and so compact trees
only store the nonempty parts explicitly.
The empty compact tree (with no assets stored at leaves) can be thought of as
represented by {\val{None}}, and the type {\type{ctree option}}
is used when the empty compact tree should be considered.

Compact trees $\cC$ are values of type ${\type{ctree}}$, which is defined by the following constructors.
\begin{itemize}
\item ${\constr{CLeaf}}(\overline{b},\cH)$ is a compact tree with a single nonempty leaf
at the location determined by the bit sequence (list of booleans) $\overline{b}$
and containing the nonempty hlist $\cH$.
\item ${\constr{CHash}}(h)$ is a compact tree with a hash $h$. This approximates every compact tree with hash root $h$.
\item ${\constr{CAbbrev}}(h_r,h_a)$ is an abbreviation for a compact tree with hash root $h_r$
and which hashes to give $h_a$.
The actual compact tree which hashes to $h_a$
should be saved in a file which can be loaded into memory as needed.\footnote{In the corresponding Coq code, there is no notion of an abbreviation node. This was added in the implementation because too much memory is consumed if one attempts to keep entire compact trees in memory.}
\item ${\constr{CLeft}}(\cC)$ is the compact tree with $\cC$ as its left child and the empty tree as its right child.
\item ${\constr{CRight}}(\cC)$ is the compact tree with the empty tree as its left child and $\cC$ as its right child.
\item ${\constr{CBin}}(\cC_0,\cC_1)$ is the compact tree with two nonempty children: $\cC_0$ on the left and $\cC_1$ on the right.
\end{itemize}
Elements of type ${\type{ctree}}$ can be serialized and deserialized using
{\serfunc{seo\_ctree}}
and
{\serfunc{sei\_ctree}}.

Three hashing functions are important:
\begin{itemize}
\item {\func{hashctree}} computes a unique hash value for a compact tree.
This is used to obtain a unique name identifying a compact tree
and is used, in particular, to give names to files storing a binary
representation of the compact tree.
\item {\func{ctree\_hashroot}} computes a hash root for the compact tree.
Many different compact trees will give the same hash roots, however they will
always approximate the same ledger state.
For example, they can differ in where they include ${\constr{CHash}}$
and ${\constr{CAbbrev}}$ nodes, as well has the level of detail included in
hlists at the leaves.
\item {\func{octree\_hashroot}} takes an optional compact tree and returns an optional hash value.
It simply returns {\val{None}} for the empty compact tree {\val{None}}
and returns the result of {\func{ctree\_hashroot}} otherwise.
\item {\func{ctree\_lookup\_asset}} takes an asset id (a hash value), a ctree and a bit sequence.
It traverses to leaf in the ctree following the bit sequence.
It then tries to look up the asset with the asset id in the nonempty hlist at the leaf.
If the leaf is empty or the asset is not found, then {\val{None}} is returned. Otherwise, the asset is returned.
\item {\func{remove\_hashed\_ctree}} deletes a file in which an abbreviated compact tree has been saved.
\item {\func{archive\_unused\_ctrees}} uses the difference between two compact trees to determine which compact tree abbreviations can be ``archived.'' The intention is that once a block height has become a checkpoint,
then the nodes in the compact tree unused beyond that height will no longer be needed.
These nodes are simply listed in a file {\file{archive}} and can be explicitly deleted later.
\item {\func{remove\_unused\_ctrees}} is similar to {\func{archive\_unused\_ctrees}} except that
it actually deletes the files.
\item {\func{ctree\_pre}} takes a bit sequence, a compact tree and an integer
and returns the subtree located where the bit sequence indicates (or {\val{None}} if
the subtree is empty, hence implicit) along with the depth.\footnote{It is unclear why the depth is returned or even computed as it seems to be simply the length of the bit sequence added to the integer. It is possible this is simply a remnant of some debugging information.}
\item {\func{ctree\_addr}} given an address and a compact tree,
returns the leaf (as a compact tree) at that address.
This leaf could either be {\val{None}} indicating no assets are held at the address,
or it could be a nonempty hlist, approximating the assets held at the address.
It also returns the depth, which should always be 162, so it can be ignored.
\item {\func{get\_ctree\_abbrev}} loads and returns a ctree given its hash, or
raises the {\exc{Failure}} exception if the appropriate file cannot be found.
\item {\func{octree\_lub}} takes the ``least upper bound'' of two optional compact trees.
These are assumed to be ``compatible'' in the sense that they must have the same hash root.
This means either both will be empty ({\val{None}})
or both will be compact trees.
The least upper bound of two empty compact trees is the empty compact tree.
For nonempty compact trees, the recursive structure is followed,
abreviations are expanded, and if one of the trees is a {\constr{CHash}}
node then the other tree is taken.
The idea is that if some information is in at least one of the trees,
then the information will be in the resulting tree.
\item {\func{print\_ctree}} and {\func{print\_ctree\_all}} print compact trees and are included for debugging purposes.
\end{itemize}

\subsection{Local Frames and Remote Frames}

A {\defin{frame}} specifies how to represent a compact tree,
including information about which parts of the tree should
be explicit and which should be summarized as a hash root.
In addition, a local frame specifies when to save
part of a compact tree in a file as an abbreviation.
There are two types of frames implemented as the types
{\type{frame}} (for {\defin{local frames}}) and {\type{rframe}} (for
{\defin{remote frames}}).\footnote{In the Coq formalization, there is
no notion of a frame. Local frames were implemented to have a way of
saving parts of a compact tree in local files, to be loaded when
needed. Remote frames were implemented to have a way of communicating
to remote nodes which part of the compact tree are being explicitly
stored and modified by a node. Such information would be useful for a
node that wanted to request a previously unfollowed part of the
compact tree. At the moment, local frames are used to save parts of
compact trees in files in the {\dir{ctrees}} directory, while remote
frames are not used at all.}

Local frames $\cF$ (or simply {\defin{frames}}) are elements of the type {\type{frame}}, which is defined with the
following constructors:
\begin{itemize}
\item ${\constr{FHash}}$ indicates that only the hash root of the corresponding compact tree should be stored.
\item ${\constr{FAbbrev}}(\cF)$ indicates that the corresponding compact tree $\cC$ should be represented
as an abbreviated pair of hash values $h_r$ and $h_a$.
Here $h_r$ is the hash root of the compact tree and $h_a$ is a full hash of the
compact tree $\cC'$ resulting from representing $\cC$ according to the frame $\cF$.
\item ${\constr{FAll}}$ indicates that the full compact tree should be included.
\item ${\constr{FLeaf}}(\overline{b},n)$ indicates that only the indicated leaf should be included, and all other nonempty parts should be approximated by ${\constr{CHash}}$-nodes.\footnote{This is intended to be useful if a node wants to follow specific addresses.}
The optional value $n$ indicates how long of an asset prefix the nonempty hlist at the leaf should explicitly list. If $n$ is {\val{None}}, then all assets are listed.
\item ${\constr{FBin}}(\cF_0,\cF_1)$ indicates that the left child of the compact tree should be represented according to $\cF_0$ and the right child according to $\cF_1$.
\end{itemize}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_frame}}
and
{\serfunc{sei\_frame}}.

Remote frames $\cR$ are elements of the type {\type{rframe}}
and essentially consists of frames without abbreviation nodes.
Hence the type is defined by four constructors which correspond to the other four
constructors described above:
\begin{itemize}
\item ${\constr{RFHash}}$
\item ${\constr{RFAll}}$
\item ${\constr{RFLeaf}}(\overline{b},n)$
\item ${\constr{RFBin}}(\cF_0,\cF_1)$
\end{itemize}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_rframe}}
and
{\serfunc{sei\_rframe}}.

The current local frame is stored in the variable
{\var{localframe}} and the hash of the current local
frame is stored in the variable {\var{localframehash}}.
These values are intended to be set upon start-up
by loading a value from a file (see {\func{load\_currentframe}})
and be modifiable by the user.
(There is code in {\file{qeditascli.ml}} to change the current frame
using commands,
calling some of the functions described below.)

A remote frame of the form ${\constr{RFBin}}({\constr{RFAll}},{\constr{RFAll}})$
is a redex with reduct ${\constr{RFAll}}$.
A remote frame is normal if it has no redexes.

We briefly describe some of the functions involving frames
exported by the {\module{ctre}} module.
\begin{itemize}
\item {\func{frame\_filter\_ctree}} takes a local frame $\cF$ and a compact tree $\cC$
and changes the representation of $\cC$ according to $\cF$.
This means nodes in $\cC$ corresponding to ${\constr{FHash}}$ nodes in $\cF$
are replaced by ${\constr{CHash}}$ nodes storing the hash root of the node.
It also means nodes in $\cC$ corresponding to ${\constr{FAbbrev}}$ nodes in $\cF$
are replaced by ${\constr{CAbbrev}}$ nodes storing the hash root and full hash of the node,
saving the subtree in a file if necessary.
It is possible that $\cC$ does not have enough information to form the
representation required by $\cF$ (e.g., if a ${\constr{CHash}}$ node occurs in $\cC$ corresponds
to ${\constr{FBin}}$ in $\cF$),
in which case the exception {\exc{InsufficientInformation}} is raised.
\item {\func{frame\_filter\_octree}} is a wrapper for {\func{frame\_filter\_ctree}} handling
optional ctrees, sending {\val{None}} to {\val{None}}.
\item {\func{rframe\_filter\_ctree}} is similar to {\func{frame\_filter\_ctree}} except using remote frames.
\item {\func{rframe\_filter\_octree}} is similar to {\func{frame\_filter\_octree}} except using remote frames.
\item {\func{normalize\_frame}} takes a local frame and creates a remote frame
by removing abbreviation nodes and by normalizing the result.
\item {\func{rframe\_lub}} combines two normalized remote
 frames to give a normalized remote frame
 describing what at least one of the two frames stores.
 The intention is that this function could be used for a peer to summarize
 what information at least one of its peers has, and then share this
 summary with all peers. In principle this could help locate a peer with specific
 information in the ledger tree.
\item {\func{wrap\_frame}} ensures that a local frame starts with ${\constr{FAbbrev}}$, by adding it if necessary.
\item {\func{hashframe}} hashes a frame to obtain a unique identifier for it.
\item {\func{frame\_add\_leaf}} changes a frame so that a given leaf (specified by an address)
will be explicit, possibly up to a given prefix length.
\item {\func{frame\_set\_hash\_pos}} changes a frame so that a certain position (specific by a list of booleans) will be summarized by a hash root.
\item {\func{frame\_set\_abbrev\_pos}} changes a frame so that a certain position will be abbreviated.
\item {\func{frame\_set\_abbrev\_level}} changes a frame to ensure that every node at a certain
level of a tree will be abbreviated.\footnote{One example of a frame that has been used to compute the initial distribution compact tree has abbreviations at levels $2$, $10$ and $18$. This means that the top two levels of the compact tree will end in abbreviations for the trees representing p2pkh addresses, p2sh addresses, term addresses and publication addresses. These subtrees in turn will have abbreviations corresponding to the first and second bytes of the addresses.}
\item {\func{frame\_set\_all\_pos}} changes a frame so that everything below a certain position will be explicit.
\item {\func{build\_rframe\_to\_req}} takes a local frame and a compact tree
and finds the parts of the compact tree where information is missing.
These missing parts are used to create a remote frame.
The intention is that this remote frame can be used to request the missing
information from peers.
\item {\func{split\_rframe\_for\_reqs}} takes an integer $n$ and a remote frame
and returns a list of remote frames with the given frame as a least upper bound.
This is essentially computed by traversing to depth $n$ and partitioning the
request into $2^n$ parts to request.
The intention is to use this to factor large requests 
into small requests of parts of the compact tree from peers.
\item {\func{load\_root\_abbrevs\_index}} loads the contents of a file {\file{rootabbrevsindex}}
which associates hash roots of compact trees
to hashes of local frames and compact trees.
This index is used to find the abbreviation for a compact tree given a hash root
and hash of a local frame.
The intention is to only store this information for the hash root for the top
of a compact tree (corresponding to addresses, i.e., 162-bit sequences)
and not subtrees (of which there are too many).
\item {\func{lookup\_frame\_ctree\_root\_abbrev}} takes a hash root of a compact tree
and the hash of a local frame
and returns the hash of the compact tree
(or raises the exception {\exc{Not\_found}}).
Note that this hash is needed to load the abbreviation.
\item {\func{lookup\_all\_ctree\_root\_abbrevs}} takes a hash root and returns a list of
pairs of hash values, the first being the hash of a local frame
and the second being the hash of a corresponding compact tree.
\end{itemize}

\subsection{Transactions}

We now describe functions relating compact trees and transactions.
One of the main concepts is that of {\defin{support}}.
In short, we say a compact tree supports a transaction if for each
input there is a corresponding asset held at the given address
and that a number of conditions hold.
To be more precise, there are further dependencies.
For example, some of these conditions depend on the block height
(e.g., to ensure an old enough intention justifies a publication).\footnote{Lock heights are not checked here, but instead are checked with the signatures of transactions. The reason is that lock heights prevent an asset from being spent, but do not prevent assets from being moved. The distinction between being spent and being moved is not relevant for support.}
Also, we must check the correctness of publications
which may require looking up a theory or signature.
These dependencies
are explicit in the function {\func{ctree\_supports\_tx}}
which checks if a compact tree supports a transaction,
given a block height, theory tree ({\type{ttree}}) and signature tree ({\type{stree}}).
The conditions to be checked often make reference to the actual assets
being spent (which are referred to in the transaction by their assetids).
The function {\func{ctree\_lookup\_input\_assets}} elaborates
the inputs by looking up the assets.
The exception {\exc{NotSupported}} is raised if
some condition required for a transaction to be supported fails,
which can happen either because the assets being spent cannot be found
in the compact tree or because of failure of some condition.

Let $\cC$ be a compact tree.
We say an asset $a$ is {\defin{held at $\alpha$ in $\cC$}}
if there is a nonempty hlist $\cH$ at leaf $\alpha$ in $\cC$ and $a$
is explicitly listed in $\cH$ (see {\func{in\_nehlist}}).
Let $\iota$ be an {\type{addr\_assetid}} list (a list of transaction inputs)
and $\iota'$ be a list of pairs $(\alpha,a)$ of addresses and assets.
We say $\iota'$ is an {\emph{elaboration of $\iota$ relative to $\cC$}}
if for each $(\alpha,h) \in\iota$ there is a pair $(\alpha,a) \in\iota'$
where $a$ is held at $\alpha$ in $\cC$ and $a$ has assetid $h$.\footnote{Technically, in the implementations the lists $\iota$ and $\iota'$ will list assetids and assets in the same order.}
The function {\func{ctree\_lookup\_input\_assets}} 
computes an elaboration $\iota'$ given $\iota$ and $\cC$,
raising {\exc{NotSupported}} if 
there is no asset $a$ with assetid $h$ held at $\alpha$ in $\cC$
for some $(\alpha,h)$ in $\iota$.

The function {\func{ctree\_supports\_tx}} simply
calls {\func{ctree\_lookup\_input\_assets}} to obtain $\iota'$
and then calls {\func{ctree\_supports\_tx\_2}} with this extra information.
The function {\func{ctree\_supports\_tx\_2}} checks the conditions for
$\cC$ to support $\tau=(\iota,o)$ with elaborated input $\iota'$
relative to a block height $b$, a theory tree and a signature tree.\footnote{The function {\func{ctree\_supports\_tx\_2}} is also given a list of assets, but this is simply the second components of the pairs in $\iota'$.}
Support requires several conditions.
We describe each condition as a single sentence followed by
a longer description.\footnote{Similar conditions can also be found in the Coq formalization as {\coqfunc{ctree\_supports\_tx}} in {\file{CTrees.v}}.}
\begin{enumerate}
\item {\sc{All output addresses are supported.}}
That is, for each $(\alpha,u)\in o$ there is no ${\constr{CHash}}$ node along the
path to the leaf in $\cC$ with position $\alpha$.
This is needed so that the new assets can be added to the leaves.
For each $(\alpha,u)\in o$ there are two possibilities: either there are no assets currently
held at $\alpha$
or there are assets represented by the nonempty hlist $\cH$ at $\alpha$.
If there are no assets, the new nonempty hlist will only contain the new assets.
If there are currently assets represented by $\cH$, we only need to
push the new assets onto the explicit prefix of $\cH$.
Note that this is possible even if $\cH$ is only the hash root of the hlist.
\item {\sc{If an object or a proposition is used in a signature specification, then it must be free to use.}}
For the definition of ``used'' see
{\func{output\_signaspec\_uses\_objs}}
and
{\func{output\_signaspec\_uses\_props}}.
Recall that each signature specification is intended for a specific theory (possibly the empty theory).
Each parameter in a signature specification will correspond to two term
addresses: one for the pure object and one for the object in the theory.
Both of these addresses must be owned as objects and the ownership assets
must both give $0$ as the price of a right to use the object.
Likewise each axiom in a signature specification will correspond to two term
addresses: one for the pure proposition and one for the proposition in the theory.
Both of these addresses must be owned as propositions and the ownership assets
also must give $0$ as the price of a right to use the proposition.
The reason for this condition is to prevent someone from paying once
for the right to use an object or a proposition
and then publishing it in a signature which is then free for anyone to use.
Of course, someone can purchase the ownership assets from the owners
and then make the corresponding objects and propositions free to use.
\item {\sc{If rights are spent in the input, then they must be mentioned in the output.}}
If a preasset ${\constr{RightsObj}}(\beta,n)$ is being spent, then 
$\beta$ must be ``mentioned'' (see {\func{obj\_rights\_mentioned}})
in the sense that there is either an output of the form
${\constr{RightsObj}}(\beta,m)$
or the object is used (as a parameter) in a document being published.
If a preasset ${\constr{RightsProp}}(\beta,n)$ is being spent, then 
$\beta$ must be ``mentioned'' (see {\func{prop\_rights\_mentioned}})
in the sense that there is either an output of the form
${\constr{RightsProp}}(\beta,m)$
or the proposition is used (as an axiom) in a document being published.
\item {\sc{Rights must be balanced.}}
Let $\alpha$ be a term address corresponding to an object [a proposition] used in a document.
Ensure that all the assets held at $\alpha$ are explict
(using {\func{hlist\_full\_approx}})
and look up the ownership asset for $\alpha$ as an object [a proposition].
(Such ownership assets are held at $\alpha$.)
If $\alpha$ has no owner, then the transaction is not supported.
Let $r_1$ be the number of rights to $\alpha$ used as an object [a proposition].
That is, $r_1$ is the number of documents which import $\alpha$ as a parameter [an axiom].
This is computed using {\func{count\_rights\_used}}.
Let $r_2$ be the number of rights to $\alpha$ as an object [a proposition]
which are created in the output of the transaction.
This is computed using {\func{rights\_out\_obj}} [{\func{rights\_out\_prop}}]
and can be described as a simple sum:
$$
\sum_{{\constr{RightsObj}(\alpha,m)} {\mbox{ in }} o} m
\,\,
\left[
\sum_{{\constr{RightsProp}(\alpha,m)} {\mbox{ in }} o} m
\right]
$$
Let $r_3$ be the number of rights to $\alpha$ as an object [a propostion]
which are spent in the input of the transaction.
This is computed using {\func{count\_obj\_rights}} [{\func{count\_prop\_rights}}]
and can be described as a simple sum:
$$
\sum_{{\constr{RightsObj}(\alpha,m)} {\mbox{ in }} \iota'} m
\,\,
\left[
\sum_{{\constr{RightsProp}(\alpha,m)} {\mbox{ in }} \iota'} m
\right].
$$
The function {\func{ctree\_rights\_balanced}} is called with this information,
returning a boolean indicating if the rights are {\defin{balanced}}.
Rights being balanced depends on the cost to purchase rights which is found in the
ownership asset.
If the cost to purchase rights is {\val{None}} (meaning rights cannot be purchased),
then rights are balanced if $r_1 + r_2 = r_3$.\footnote{In practice, $r_1 > 0$ since the object or proposition was used. Hence the only way this equation can hold is if $r_3>0$. This is possible if rights to use
the object or proposition were purchased earlier at a time when rights were being sold.}
If the cost to purchase rights is $0$, then the rights are balanced.\footnote{Note that this means anyone can create rights to use the object or proposition later.}
Assume the ownership asset is of the form ${\constr{OwnsObj}}(\beta,p)$
[${\constr{OwnsProp}}(\beta,p)$] where $p>0$.
That is, the cost to purchase rights is $p>0$. In this case it is possible rights are being purchased
by paying cants to $\beta$.
Let $r_4$ be the sum of cants sent to $\beta$ in the output $o$.
The rights are balanced if $r_1+r_2 = r_3+r_4$.\footnote{There is a corner case here. If the same pay address $\beta$ was used in more than one ownership asset at term addresses $\alpha_1$ and $\alpha_2$, then someone could simultaneously create rights to use $\alpha_1$ and $\alpha_2$ by paying cants to $\beta$ once in a single transaction. This can be avoided by always giving a unique pay address for distinct ownership assets. This uniqueness is not enforced.}
The transaction is not supported if the rights are not balanced.
\item {\sc{Publications are correct, new and were declared in advance by a sufficiently old intention (marker).}}
Recall that there are three kinds of publications:
theory specifications, signature specifications and documents.
The corresponding preassets are
${\constr{TheoryPublication}}(\gamma,\nu,\tau)$,
${\constr{SignaPublication}}(\gamma,\nu,h,\Sigma)$
and
${\constr{DocPublication}}(\gamma,\nu,h,\Delta)$.
Recall that $\nu$ is a nonce.
There will be two publication addresses associated with the publication.
One is determined simply by the contents ($\tau$, $(h,\Sigma)$ or $(h,\Delta)$)
and must be the $\alpha$ (in $o$) where the publication asset will be held.
(This is checked in {\func{tx\_outputs\_valid\_addr\_cats}}.)
The $\alpha$ must be empty or the transaction is not supported.
(If $\alpha$ holds an asset, it implies the publication has already been published.)
All the information (including $\gamma$ and $\nu$)
can be hashed to obtain a publication address $\beta$,
called the {\defin{marker address}}.
The author of the document was able to compute this publication address $\beta$
before making the corresponding publication (included in the preasset) public
without revealing information about the publication's contents.
The author must publish a {\constr{Marker}} asset
to the address $\beta$ a certain number of blocks before attempting to publish
the transaction with the publication.\footnote{The purpose of this is to prevent plagiarism, as described when ${\constr{Marker}}$ was introduced in Chapter~\ref{chap:assetstx}.}
The number of blocks is {\var{intention\_minage}} which is currently set to $144$ (a day, assuming 10 minute block times).
This {\constr{Marker}} must be spent by the transaction (assuring it exists)
and must be old enough, otherwise the transaction is not supported.
Finally, the publication must be correct.
Correctness is judged by {\func{check\_theoryspec}}, {\func{check\_signaspec}} or {\func{check\_doc}}.
In the cases of {\func{check\_signaspec}} or {\func{check\_doc}},
the appropriate theory (if nonempty) must be looked up in the current theory tree,
and the current signature tree must be given so that signatures imported by
the signature specification or document can be retrieved.
Also, recall that {\func{check\_signaspec}} and {\func{check\_doc}}
depend on arguments
{\var{gvtp}} and
{\var{gvkn}}
where 
{\var{gvtp}} determines if an term is known to have a type in a theory
and
{\var{gvkn}} determines if a proposition is known to be provable in a theory.
Now that we have access to the compact tree $\cC$,
we are in a position to supply these arguments.
In particular, {\var{gvtp}} computes the term address $\alpha'$ for the object in the given theory
(which depends on the theory identifier,
the hash root of the term in question and the hash of the type in question)
and uses {\func{hlist\_lookup\_obj\_owner}} to determine if $\alpha'$
is known to have an owner as an object.
Similarly, {\var{gvkn}} computes the term address $\alpha'$ for the proposition in the given theory
(which depends on the theory identifier and
the hash root of the term in question)
and uses {\func{hlist\_lookup\_prop\_owner}} to determine if $\alpha'$
is known to have an owner as a proposition.
Since term addresses can only be given owners as objects [propositions]
when they are published in a document, the type correctness [provability]
is guaranteed by ownership.
\item {\sc{If a marker asset is being spent in the input, then there must be a corresponding publication in the output.}}
Suppose $(\beta,a)\in\iota'$
where the preasset of $a$ is {\constr{Marker}}.
There must be some
${\constr{TheoryPublication}}(\gamma,\nu,\tau)$,
${\constr{SignaPublication}}(\gamma,\nu,h,\Sigma)$
or
${\constr{DocPublication}}(\gamma,\nu,h,\Delta)$
in $o$
for which $\beta$ is the marker address.
\item {\sc{If an ownership asset is spent in the input, then it must be included as an output.}}
That is, once a term address has an owner, it will always have an owner.
This is necessary since ownership is used to determine which objects have certain types and which propositions
have been proven (in both cases relative to a theory).
The ownership asset may be spent and recreated for a number of reasons.
It can be done to change the pay address or the purchase price of rights.
Such a change could correspond to the ownership being sold from one party to another,
where the payment for the sale is part of the same (atomic) transaction.
Another reason would be to collect a bounty.
Ownership of propositions and negated propositions are spent (and recreated) as part of
a transaction which collect bounties.
(Collecting bounties is the only reason for ownership of negated propositions.)
Note that the signature to spend an ownership asset is the pay address in the obligation,
not the pay address for the purchase of rights.
The pay address in the obligation indicates the ``owner'' of the term address.\footnote{Ownership assets always have nontrivial obligations.}
\item {\sc{New ownership preassets in the transaction outputs must have an explicit (non-reward) obligation and must be created or transferred. If an ownership output is being created, it must be supported by the transaction outputs.}}
Suppose $(\alpha,(\omega,u))\in o$ where $u$ is either ${\constr{OwnsObj}}(\beta,p)$,
${\constr{OwnsProp}}(\beta,p)$ or ${\constr{OwnsNegProp}}$.
The obligation $\omega$ must not be $\val{None}$ and must indicate it is not a reward.
There must either be an ownership asset at $\alpha$ listed in $\iota'$ (so ownership is being transferred)
or no ownership asset is held at $\alpha$ in $\cC$ (so the ownership is being created).
If the ownership asset is being created, then $o$ must support $u$ at $\alpha$ (see Section~\ref{sec:outputcreates}).
\item {\sc{New objects and propositions must be given ownership by the transaction publishing the document.}}
There are three different cases.
(The notions of ``creates'' used here were defined in see Section~\ref{sec:outputcreates}.)
If $o$ creates an object at term address $\alpha$
and there is no ${\constr{OwnsObj}}$ asset held at $\alpha$ in $\cC$,
then there must be some
$(\alpha,(\omega,{\constr{OwnsObj}}(\beta,p)))\in o$.
If $o$ creates a proposition at term address $\alpha$
and there is no ${\constr{OwnsProp}}$ asset held at $\alpha$ in $\cC$,
then there must be some
$(\alpha,(\omega,{\constr{OwnsProp}}(\beta,p)))\in o$.
(There is no requirement that created negated propositions must be given ownership.)
\item {\sc{Bounties can only be collected by the owners of propositions or negated propositions.}}
Suppose $(\alpha,a)\in\iota'$
and the preasset of $a$ is ${\constr{Bounty}}(v)$.
There must also be some $(\alpha,a')\in\iota'$ (with the same $\alpha$)
where the preasset of $a'$ is either ${\constr{OwnsProp}}(\beta,p)$
(for some $\beta$ and $p$)
or ${\constr{OwnsNegProp}}$.
The fact that ownership asset is being spent means that the ``owner'' (as given in the obligation of $a'$)
must have signed the transaction spending the bounty.
Note that by a condition above, the ownership asset must be recreated in the output $o$.
The idea is that an owner of the proposition or negated proposition collects
the bounty by a trivial transfer of the ownership asset.
\end{enumerate}
An attentive reader will note that none of these conditions require the currency units consumed
in the input to be at least as great as the currency units created in the outputs (plus those
required to be burned to publish theories and signatures).
This is not required for support,
and will not be true for coinstake transactions (which receive a reward).

We summarize the descriptions of these three main functions discussed above as follows:
\begin{itemize}
\item {\func{ctree\_lookup\_input\_assets}} takes a compact tree and an
{\type{addr\_assetid}} list (a list of transaction inputs)
and uses {\func{ctree\_lookup\_asset}} to look up the assets corresponding to
the assetids, returning the resulting list of pairs of addresses and assets.
If one of the assetids cannot be found in the compact tree,
the exception {\exc{NotSupported}} is raised.
\item {\func{ctree\_supports\_tx}} checks if a compact tree supports a transaction.
The function also requires an optional {\type{ttree}} (with all the currently known theories)
an optional {\type{stree}} (with all the currently known signatures)
and the current block height.
If the transaction is not supported, the exception {\exc{NotSupported}} is raised.
If the transaction is supported,
the difference between the currency units output or burned and the currency units input
is returned. If this value is negative, then it corresponds to a fee.
If the value is positive, then it corresponds to a reward.
\item {\func{ctree\_supports\_tx\_2}} is the same as {\func{ctree\_supports\_tx}}
except it also receives two extra inputs:
a list of the input addresses associated with their assets
and a list of those assets.
\end{itemize}

If a compact tree supports a transaction or list of transactions,
typically some small approximation of the compact tree also provides the support.
We next describe functions to construct such small approximations.
\begin{itemize}
\item {\func{full\_needed}} takes a {\type{addr\_preasset}} list (a list of transaction outputs)
and returns a list of bit sequences (addresses represented as boolean lists)
indicating which leaves need to have their full list of assets explicit
in order to check if the transaction with these outputs
is supported. 
\item {\func{get\_tx\_supporting\_octree}} takes a transaction and (optional) compact tree
and returns an approximation of the (optional) compact tree sufficient to support the transaction.
\item {\func{get\_txl\_supporting\_octree}} takes a list of transactions and (optional) compact tree
and returns an approximation of the (optional) compact tree sufficient to support the transactions.
\end{itemize}

There are two functions which transform (optional) compact trees using transactions.
\begin{itemize}
\item {\func{tx\_octree\_trans}} takes a block height, transaction and compact tree
and transforms the ctree by deleting assets consumed in the inputs and
create the new assets in the output. (The block height is needed to give
birthdays to the new assets.)
\item {\func{txl\_octree\_trans}} transforms a compact tree according to a
list of transactions, sequentially.
\end{itemize}

There are also four auxiliary functions exposed in the interface.
\begin{itemize}
\item {\func{strip\_bitseq\_true}} takes a list of pairs, the first component of which are bit sequences, and returns the list
filtered to the ones with a {\val{true}} as the head of the list with this {\val{true}} removed.
For example, the input
$$[((\val{false}::\overline{b_0}),x);((\val{true}::\overline{b_1}),y)]$$
would give the output
$$[(\overline{b_1},y)].$$
\item {\func{strip\_bitseq\_false}} takes a list of pairs, the first component of which are bit sequences, and returns the list
filtered to the ones with a {\val{false}} as the head of the list with this {\val{false}} removed.
For example, the input
$$[((\val{false}::\overline{b_0}),x);((\val{true}::\overline{b_1}),y)]$$
would give the output
$$[(\overline{b_0},x)].$$
\item {\func{strip\_bitseq\_true0}} takes a list of bit sequences, and returns the list
filtered to the ones with a {\val{true}} as the head of the list with this {\val{true}} removed.
\item {\func{strip\_bitseq\_false0}} takes a list of bit sequences, and returns the list
filtered to the ones with a {\val{false}} as the head of the list with this {\val{false}} removed.
\end{itemize}
These are exposed because they are used in the {\module{ctregraft}} module.\footnote{It might make more sense to combine the {\module{ctre}} and {\module{ctregraft}} modules so that these functions need not be exposed.}

\section{Grafting Trees}

The module {\module{ctregraft}}
has code for grafting subtrees onto a compact tree in order
to form an approximation with more information.
The purpose of this is so that a block header can
have a compact tree small enough to check the details of the asset which
staked the block,
and the block delta can have a graft extending this compact tree
to a larger compact tree with enough information to support
all the transactions in the block.

{\bf{Note:}} 
In the Coq formalization the Coq module {\coqmod{CTreeGrafting}}
corresponds to {\module{ctregrafting}}.
For more information, see~\cite{White2015b}.

The type {\type{cgraft}} is a list of hash values associated with compact trees.
The idea is simply to associate some hash roots with compact trees with these hash roots.
As usual, the serialization and deserialization functions
for this type are
{\serfunc{seo\_cgraft}}
and
{\serfunc{sei\_cgraft}}.

There are four functions exposed by {\module{ctregraft}}.
\begin{itemize}
\item {\func{cgraft\_valid}} checks if a graft is {\defin{valid}}, meaning simply that
each pair $(h,\cC)$ is such that the hash root of $\cC$ is $h$.
\item {\func{ctree\_cgraft}} takes a graft $\cG$ and a compact tree $\cC$
and replaces each ${\constr{CHash}}(h)$ in $\cC$ with $\cC'$
where $(h,\cC')$ is in $\cG$.
\item {\func{factor\_tx\_ctree\_cgraft}} takes a transaction and a compact tree $\cC$
and computes a pair $(\cC',\cG)$ of a compact tree $\cC'$ and a graft $\cG$.\footnote{This function is currently unused.}
Here $\cC'$ is an approximation of $\cC$
and {\func{ctree\_cgraft}} applied to $\cG$ and $\cC'$ yields $\cC$.
\item {\func{factor\_inputs\_ctree\_cgraft}} takes an {\type{addr\_assetid}}
(a list of transaction inputs)
and a compact tree $\cC$
and computes a pair $(\cC',\cG)$ of a compact tree $\cC'$ and a graft $\cG$.
Here $\cC'$ is an approximation of $\cC$
and {\func{ctree\_cgraft}} applied to $\cG$ and $\cC'$ yields $\cC$.
The purpose of this function is to factor the part of the compact tree
needed for the block header from the part needed for the rest of the block.
\end{itemize}
