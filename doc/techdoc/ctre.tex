\module{ctre}
\module{ctregraft}

{\bf{Note:}} Unit tests for the {\module{ctre}} and {\module{ctregraft}} modules are in {\file{ctreunittests.ml}}
in the {\file{src/unittests}}
directory in the {\branch{testing}} branch.
These unit tests give a number of examples demonstrating how the functions described below should behave.

\section{Compact Ledger Trees}

\module{ctre}

{\bf{Note:}} The largest part of the Coq formalization deals with verifying compact trees
indeed represent ledgers as intended.
The Coq module {\coqmod{LedgerStates}} represents ledgers as functions
describing the current state of the ledger (see the Coq type \coqtype{statefun}).
The Coq module {\coqmod{MTrees}} uses a form of Merkle tree~\cite{Merkle1980} to approximate such a
{\coqtype{statefun}} function.
The Coq types {\coqtype{hlist}} and {\coqtype{nehlist}} defined in {\coqmod{MTrees}} correspond to 
the types {\type{hlist}} and {\type{nehlist}} defined in {\module{ctre}} in the OCaml code.
The dependent Coq type {\coqtype{mtree}} $n$ is a Merkle tree with height $n$,
where the default case is $n=162$ (since Qeditas addresses are determined by 162 bits).
The Coq module {\coqmod{CTrees}} uses the compact tree (essentially a Patricia tree)
to represent the Merkle tree and hence approximate the ledger state.
The dependent Coq type {\coqtype{ctree}} $n$ is a compact tree with height $n$.
In the OCaml code the corresponding type is the simple type {\type{ctree}}.
Several functions are defined by recursion on $n$ in both the Coq and OCaml versions,
even though in the OCaml version the requirement that the compact tree has height $n$
is no longer enforced by the type system.
Note that {\coqmod{CTrees}} (mostly) corresponds to {\module{ctre}},
while {\coqmod{LedgerStates}} and {\coqmod{MTrees}} are only needed in the theory
and (for the most part) have no counterpart in the OCaml code.
Note also that frames and compact tree abbreviation nodes are not
represented in the Coq formalization as these were added later to the
OCaml code.
For more information, see~\cite{White2015b}.

% move reward_maturation and reward_locktime

\begin{itemize}
\item {\type{hlist}}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_hlist}}
and {\serfunc{sei\_hlist}}.
\item {\type{nehlist}}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_nehlist}}
and
{\serfunc{sei\_nehlist}}.
\item {\type{frame}}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_frame}}
and
{\serfunc{sei\_frame}}.
\item {\type{rframe}}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_rframe}}
and
{\serfunc{sei\_rframe}}.
\item {\type{ctree}}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_ctree}}
and
{\serfunc{sei\_ctree}}.
\end{itemize}

\begin{itemize}
\item {\var{localframe}}
\item {\var{localframehash}}
\end{itemize}

{\exc{NotSupported}}

\begin{itemize}
\item {\func{coinage}}
\item {\func{hlist\_hashroot}}
\item {\func{nehlist\_hlist}}
\item {\func{nehlist\_hashroot}}
\item {\func{normalize\_frame}}
\item {\func{rframe\_lub}}
\item {\func{hashctree}}
\item {\func{ctree\_hashroot}}
\item {\func{octree\_hashroot}}
\item {\func{ctree\_lookup\_asset}}
\item {\func{remove\_hashed\_ctree}}
\item {\func{archive\_unused\_ctrees}}
\item {\func{remove\_unused\_ctrees}}
\item {\func{ctree\_pre}}
\item {\func{ctree\_addr}}
\item {\func{frame\_filter\_ctree}}
\item {\func{frame\_filter\_octree}}
\item {\func{rframe\_filter\_ctree}}
\item {\func{rframe\_filter\_octree}}
\item {\func{lookup\_all\_ctree\_root\_abbrevs}}
\item {\func{lookup\_frame\_ctree\_root\_abbrev}}
\item {\func{get\_ctree\_abbrev}}
\item {\func{load\_root\_abbrevs\_index}}
\item {\func{strip\_bitseq\_true}}
\item {\func{strip\_bitseq\_false}}
\item {\func{strip\_bitseq\_true0}}
\item {\func{strip\_bitseq\_false0}}
\item {\func{ctree\_lookup\_input\_assets}}
\item {\func{ctree\_supports\_tx}}
\item {\func{ctree\_supports\_tx\_2}}
\item {\func{tx\_octree\_trans}}
\item {\func{txl\_octree\_trans}}
\item {\func{octree\_lub}}
\item {\func{full\_needed}}
\item {\func{get\_tx\_supporting\_octree}}
\item {\func{get\_txl\_supporting\_octree}}
\item {\func{print\_hlist}}
\item {\func{print\_hlist\_to\_buffer}}
\item {\func{print\_ctree}}
\item {\func{print\_ctree\_all}}
\item {\func{wrap\_frame}}
\item {\func{hashframe}}
\item {\func{frame\_add\_leaf}}
\item {\func{frame\_set\_hash\_pos}}
\item {\func{frame\_set\_abbrev\_pos}}
\item {\func{frame\_set\_abbrev\_level}}
\item {\func{frame\_set\_all\_pos}}
\item {\func{build\_rframe\_to\_req}}
\item {\func{split\_rframe\_for\_reqs}}
\end{itemize}

\section{Grafting Trees}

\module{ctregraft}

{\bf{Note:}} 
In the Coq formalization the Coq module {\coqmod{CTreeGrafting}}
corresponds to {\module{ctregrafting}}.
For more information, see~\cite{White2015b}.

{\type{cgraft}}
with serialization function
{\serfunc{seo\_cgraft}}
and deerialization function
{\serfunc{sei\_cgraft}}.

\begin{itemize}
\item {\func{cgraft\_valid}}
\item {\func{ctree\_cgraft}}
\item {\func{factor\_tx\_ctree\_cgraft}}
\item {\func{factor\_inputs\_ctree\_cgraft}}
\end{itemize}
