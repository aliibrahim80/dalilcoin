The {\module{ctre}} module
implements compact trees (``ctrees'')
and supporting functions.
Compact trees are used to approximate the state of the ledger
by recording what assets are held at what addresses.
The {\module{ctregraft}} module
implements a way to graft information onto a compact
tree in order to form an approximation with more information.

{\bf{Note:}} Unit tests for the {\module{ctre}} and {\module{ctregraft}} modules are in {\file{ctreunittests.ml}}
in the {\file{src/unittests}}
directory in the {\branch{testing}} branch.
These unit tests give a number of examples demonstrating how the functions described below should behave.

\section{Compact Ledger Trees}

We describe the main content of the module {\module{ctre}}.

{\bf{Note:}} The largest part of the Coq formalization deals with verifying compact trees
indeed represent ledgers as intended.
The Coq module {\coqmod{LedgerStates}} represents ledgers as functions
describing the current state of the ledger (see the Coq type \coqtype{statefun}).
The Coq module {\coqmod{MTrees}} uses a form of Merkle tree~\cite{Merkle1980} to approximate such a
{\coqtype{statefun}} function.
The Coq types {\coqtype{hlist}} and {\coqtype{nehlist}} defined in {\coqmod{MTrees}} correspond to 
the types {\type{hlist}} and {\type{nehlist}} defined in {\module{ctre}} in the OCaml code.
The dependent Coq type {\coqtype{mtree}} $n$ is a Merkle tree with height $n$,
where the default case is $n=162$ (since Qeditas addresses are determined by 162 bits).
The Coq module {\coqmod{CTrees}} uses the compact tree (essentially a Patricia tree)
to represent the Merkle tree and hence approximate the ledger state.
The dependent Coq type {\coqtype{ctree}} $n$ is a compact tree with height $n$.
In the OCaml code the corresponding type is the simple type {\type{ctree}}.
Several functions are defined by recursion on $n$ in both the Coq and OCaml versions,
even though in the OCaml version the requirement that the compact tree has height $n$
is no longer enforced by the type system.
Note that {\coqmod{CTrees}} (mostly) corresponds to {\module{ctre}},
while {\coqmod{LedgerStates}} and {\coqmod{MTrees}} are only needed in the theory
and (for the most part) have no counterpart in the OCaml code.
Note also that frames and compact tree abbreviation nodes are not
represented in the Coq formalization as these were added later to the
OCaml code.
For more information, see~\cite{White2015b}.

\subsection{Coin-age}

We first consider some variables which affect the likelihood of
coins to stake.\footnote{Since this has nothing to do with compact trees, it should be moved to a more appropriate module.}
The current settings have been chosen after
doing some simulations to determine a reasonable mixture
between staking of coins in the initial distribution
vs. staking of new coins issued through block rewards.
(Initial simulations revealed that block rewards could
easily dominate staking in the first few weeks unless their
influence was dampened.)

Typically, unlocked currency assets age quadratically as $(1+\lfloor\frac{a}{512}\rfloor)^2$ where $a$ is the number of blocks
since the asset became {\defin{mature}}. This continues until a maximum age is reached.
Users may commit currency assets to stake by locking them.
Locked non-reward assets mature more quickly and, once mature, have their maximum age
until it is close to the block height at which they will be unlocked, at which point
they will be ineligible for staking.
Rewards are necessarily locked. They age like unlocked currency assets until it is close to
the block height at which they will be unlocked, at which point they will be ineligible for staking.

\begin{itemize}
\item {\var{maximum\_age}} is the number of blocks after which unlocked coins
stop aging. This is currently set to $2^{14}$. With a 10 minute average block time,
this means unlocked coins reach their maximum age after roughly $4$ months.
(Coins in the initial distribution are exceptional: they have birthday $0$ and start with their maximum age.)
\item {\var{maximum\_age\_sqr}} is $(1+\lfloor \frac{a}{512}\rfloor)^2$ where $a$ is {\var{maximum\_age}}.
This is the maximum factor that can be used to determine an asset's coin-age.
Given current settings this is $33^2$, i.e., $1089$.
\item {\var{reward\_maturation}} indicates how old a reward must be before it can begin staking. This is currently set to $512$.
\item {\var{reward\_locktime}} indicates the minimum number of blocks a reward must be locked.
This is currently set to $2^{14}$ (the same as {\var{maximum\_age}}).
This large value forces rewards not to be spent for roughly $4$ months.\footnote{This restriction is to dampen the effect
of rewards on staking. If rewards could be unlocked quickly, then they could be
spent to create a locked non-reward asset. This locked non-reward asset would
very quickly mature and begin staking with its maximum age.
If this setting is lowered to allow rewards to be spent more quickly,
then other values should be changed so that spending the reward to create
a locked non-reward assets cannot be used in a
way that rewards would quickly dominate the supply of actively staking coins.}
\item {\var{unlocked\_maturation}} indicates how many blocks must pass before
an unlocked asset can be used for staking. It is currently set to $512$.
\item {\var{locked\_maturation}} indicates how many blocks must pass before
a new locked currency asset can be used for staking.
It is currently set to $8$. This implies that $8$ blocks after creating a locked
currency asset, the currency asset can be used for staking with its maximum age,
until it is close to being unlocked.\footnote{The intention here is to encourage
stakers to commit to ``locking'' some of their coins only for use in staking.}
\item {\var{close\_to\_unlocked}} indicates the point at which locked assets can
no longer be used for staking. It is currently set to $32$, meaning that
the locked asset cannot be used for staking if it is $32$ blocks from being spendable
(or even after it is spendable).
\end{itemize}

The function {\func{coinage}} computes the {\defin{coin-age}} of a
currency asset given the current block height.
As described above the ``age'' ranges from $0$ to $1089$,
with a quadratic increase each $512$ blocks.
(Specifically, the ``age'' progresses to be $n^2$
where $n$ is incremented from $1$ to $33$ each $512$ blocks
and then remains at $33$.)
Assume $v$ is the number of cants in the currency asset.
If the birthday of the asset is $0$, then it is part of the initial distribution
and its coin-age is $1089 v$.
Other than coins in the initial distribution,
there are three cases: unlocked currency assets, locked rewards and locked non-rewards.
Unlocked currency asset and locked rewards mature after $512$ blocks and then age quadratically
as described above. In the case of locked rewards, the coin-age drops to $0$
after block height $l-32$, where $l$ is the lock given for the reward.
Locked non-rewards mature after $8$ blocks and then have coin-age $1089 v$
until the coin-age drops to $0$ after block $l-32$, where $l$ is the lock given.

\subsection{Approximating Asset Lists by Hlists}

An asset list can be approximated by an {\defin{hlist}} $\cH$, a value of type {\type{hlist}}.
The constructors for {\type{hlist}} are as follows:
\begin{itemize}
\item ${\constr{HHash}}(h)$ approximates a nonempty asset list with hash root $h$.\footnote{The hash root of an asset list does not seem to be explicitly defined in the code. However, it could be defined using {\func{ohashlist}} and {\func{hashasset}} and this seems to be the intended hash root.}
\item ${\constr{HNil}}$ approximates the empty asset list.
\item ${\constr{HCons}}(a,\cH)$ where $a$ is an asset and $\cH$ is an hlist.
\end{itemize}
The idea is that an hlist explicit lists a prefix of the assets ending with a hash root
summarizing the rest of the asset list. It is also possible for the hlist to list all the assets.
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_hlist}}
and {\serfunc{sei\_hlist}}.

The type {\type{nehlist}} represents nonempty hlists and has two constructors:
\begin{itemize}
\item ${\constr{NehHash}}(h)$ corresponds to the hlist ${\constr{HHash}}(h)$.
\item ${\constr{NehCons}}(a,\cH)$ corresponds to the hlist ${\constr{HCons}}(a,\cH)$.
\end{itemize}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_nehlist}}
and
{\serfunc{sei\_nehlist}}.

We briefly relevant functions.
\begin{itemize}
\item {\func{nehlist\_hlist}} converts a nonempty hlist to an hlist.
\item {\func{hlist\_hashroot}} computes an optional hash root for an hlist, with {\val{None}} playing
the role of the hash root for {\constr{HNil}}.
\item {\func{nehlist\_hashroot}} computes a hash root for an nehlist,
the same as the one given by {\func{hlist\_hashroot}}.
\item {\func{in\_hlist}} and {\func{in\_nehlist}} check if an asset is explicitly listed in
the hlist or nehlist. Note that this will return {\val{false}} if the asset is not explicitly listed
but is an asset on the part of the list being summarized by ${\constr{HHash}}$ or ${\constr{NehHash}}$.
\item {\func{print\_hlist}} and {\func{print\_hlist\_to\_buffer}} print hlists and are included for debugging purposes.
\end{itemize}

\subsection{Compact Trees}

The intention of a compact tree is to provide a binary tree approximation of
a function from addresses (162-bit sequences) to hlists, where the hlists
approximate the assets held at the addresses.
In general, functions on compact trees will be defined by recursion and so we
usually need to consider compact trees at level $n$ (corresponding to functions
from $n$-bit sequences to hlists).
A $0$ bit corresponds to the left child while a $1$ bit corresponds to the right child.

The vast majority of the leaves will be empty, and so compact trees
only store the nonempty parts explicitly.
The empty compact tree (with no assets stored at leaves) can be thought of as
represented by {\val{None}}, and the type {\type{ctree option}}
is used when the empty compact tree should be considered.

Compact trees $\cC$ are values of type ${\type{ctree}}$, which is defined by the following constructors.
\begin{itemize}
\item ${\constr{CLeaf}}(\overline{b},\cH)$ is a compact tree with a single nonempty leaf
at the location determined by the bit sequence (list of booleans) $\overline{b}$
and containing the nonempty hlist $\cH$.
\item ${\constr{CHash}}(h)$ is a compact tree with a hash $h$. This approximates every compact tree with hash root $h$.
\item ${\constr{CAbbrev}}(h_r,h_a)$ is an abbreviation for a compact tree with hash root $h_r$
and which hashes to give $h_a$.
The actual compact tree which hashes to $h_a$
should be saved in a file which can be loaded into memory as needed.\footnote{In the corresponding Coq code, there is no notion of an abbreviation node. This was added in the implementation because too much memory is consumed if one attempts to keep entire compact trees in memory.}
\item ${\constr{CLeft}}(\cC)$ is the compact tree with $\cC$ as its left child and the empty tree as its right child.
\item ${\constr{CRight}}(\cC)$ is the compact tree with the empty tree as its left child and $\cC$ as its right child.
\item ${\constr{CBin}}(\cC_0,\cC_1)$ is the compact tree with two nonempty children: $\cC_0$ on the left and $\cC_1$ on the right.
\end{itemize}
Elements of type ${\type{ctree}}$ can be serialized and deserialized using
{\serfunc{seo\_ctree}}
and
{\serfunc{sei\_ctree}}.

Three hashing functions are important:
\begin{itemize}
\item {\func{hashctree}} computes a unique hash value for a compact tree.
This is used to obtain a unique name identifying a compact tree
and is used, in particular, to give names to files storing a binary
representation of the compact tree.
\item {\func{ctree\_hashroot}} computes a hash root for the compact tree.
Many different compact trees will give the same hash roots, however they will
always approximate the same ledger state.
For example, they can differ in where they include ${\constr{CHash}}$
and ${\constr{CAbbrev}}$ nodes, as well has the level of detail included in
hlists at the leaves.
\item {\func{octree\_hashroot}} takes an optional compact tree and returns an optional hash value.
It simply returns {\val{None}} for the empty compact tree {\val{None}}
and returns the result of {\func{ctree\_hashroot}} otherwise.
\item {\func{ctree\_lookup\_asset}} takes an asset id (a hash value), a ctree and a bit sequence.
It traverses to leaf in the ctree following the bit sequence.
It then tries to look up the asset with the asset id in the nonempty hlist at the leaf.
If the leaf is empty or the asset is not found, then {\val{None}} is returned. Otherwise, the asset is returned.
\item {\func{remove\_hashed\_ctree}} deletes a file in which an abbreviated compact tree has been saved.
\item {\func{archive\_unused\_ctrees}} uses the difference between two compact trees to determine which compact tree abbreviations can be ``archived.'' The intention is that once a block height has become a checkpoint,
then the nodes in the compact tree unused beyond that height will no longer be needed.
These nodes are simply listed in a file {\file{archive}} and can be explicitly deleted later.
\item {\func{remove\_unused\_ctrees}} is similar to {\func{archive\_unused\_ctrees}} except that
it actually deletes the files.
\item {\func{ctree\_pre}} takes a bit sequence, a compact tree and an integer
and returns the subtree located where the bit sequence indicates (or {\val{None}} if
the subtree is empty, hence implicit) along with the depth.\footnote{It is unclear why the depth is returned or even computed as it seems to be simply the length of the bit sequence added to the integer. It is possible this is simply a remnant of some debugging information.}
\item {\func{ctree\_addr}} given an address and a compact tree,
returns the leaf (as a compact tree) at that address.
This leaf could either be {\val{None}} indicating no assets are held at the address,
or it could be a nonempty hlist, approximating the assets held at the address.
It also returns the depth, which should always be 162, so it can be ignored.
\item {\func{get\_ctree\_abbrev}} loads and returns a ctree given its hash, or
raises the {\exc{Failure}} exception if the appropriate file cannot be found.
\item {\func{octree\_lub}} takes the ``least upper bound'' of two optional compact trees.
These are assumed to be ``compatible'' in the sense that they must have the same hash root.
This means either both will be empty ({\val{None}})
or both will be compact trees.
The least upper bound of two empty compact trees is the empty compact tree.
For nonempty compact trees, the recursive structure is followed,
abreviations are expanded, and if one of the trees is a {\constr{CHash}}
node then the other tree is taken.
The idea is that if some information is in at least one of the trees,
then the information will be in the resulting tree.
\item {\func{print\_ctree}} and {\func{print\_ctree\_all}} print compact trees and are included for debugging purposes.
\end{itemize}

\subsection{Local Frames and Remote Frames}

A {\defin{frame}} specifies how to represent a compact tree,
including information about which parts of the tree should
be explicit and which should be summarized as a hash root.
In addition, a local frame specifies when to save
part of a compact tree in a file as an abbreviation.
There are two types of frames implemented as the types
{\type{frame}} (for {\defin{local frames}}) and {\type{rframe}} (for
{\defin{remote frames}}).\footnote{In the Coq formalization, there is
no notion of a frame. Local frames were implemented to have a way of
saving parts of a compact tree in local files, to be loaded when
needed. Remote frames were implemented to have a way of communicating
to remote nodes which part of the compact tree are being explicitly
stored and modified by a node. Such information would be useful for a
node that wanted to request a previously unfollowed part of the
compact tree. At the moment, local frames are used to save parts of
compact trees in files in the {\dir{ctrees}} directory, while remote
frames are not used at all.}

Local frames $\cF$ (or simply {\defin{frames}}) are elements of the type {\type{frame}}, which is defined with the
following constructors:
\begin{itemize}
\item ${\constr{FHash}}$ indicates that only the hash root of the corresponding compact tree should be stored.
\item ${\constr{FAbbrev}}(\cF)$ indicates that the corresponding compact tree $\cC$ should be represented
as an abbreviated pair of hash values $h_r$ and $h_a$.
Here $h_r$ is the hash root of the compact tree and $h_a$ is a full hash of the
compact tree $\cC'$ resulting from representing $\cC$ according to the frame $\cF$.
\item ${\constr{FAll}}$ indicates that the full compact tree should be included.
\item ${\constr{FLeaf}}(\overline{b},n)$ indicates that only the indicated leaf should be included, and all other nonempty parts should be approximated by ${\constr{CHash}}$-nodes.\footnote{This is intended to be useful if a node wants to follow specific addresses.}
The optional value $n$ indicates how long of an asset prefix the nonempty hlist at the leaf should explicitly list. If $n$ is {\val{None}}, then all assets are listed.
\item ${\constr{FBin}}(\cF_0,\cF_1)$ indicates that the left child of the compact tree should be represented according to $\cF_0$ and the right child according to $\cF_1$.
\end{itemize}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_frame}}
and
{\serfunc{sei\_frame}}.

Remote frames $\cR$ are elements of the type {\type{rframe}}
and essentially consists of frames without abbreviation nodes.
Hence the type is defined by four constructors which correspond to the other four
constructors described above:
\begin{itemize}
\item ${\constr{RFHash}}$
\item ${\constr{RFAll}}$
\item ${\constr{RFLeaf}}(\overline{b},n)$
\item ${\constr{RFBin}}(\cF_0,\cF_1)$
\end{itemize}
Elements of this type can be serialized and deserialized using
{\serfunc{seo\_rframe}}
and
{\serfunc{sei\_rframe}}.

The current local frame is stored in the variable
{\var{localframe}} and the hash of the current local
frame is stored in the variable {\var{localframehash}}.
These values are intended to be set upon start-up
by loading a value from a file (see {\func{load\_currentframe}})
and be modifiable by the user.
(There is code in {\file{qeditascli.ml}} to change the current frame
using commands.)

\begin{itemize}
\item {\func{normalize\_frame}}
\item {\func{rframe\_lub}}
\item {\func{wrap\_frame}}
\item {\func{hashframe}}
\item {\func{frame\_filter\_ctree}}
\item {\func{frame\_filter\_octree}}
\item {\func{rframe\_filter\_ctree}}
\item {\func{rframe\_filter\_octree}}
\item {\func{frame\_add\_leaf}}
\item {\func{frame\_set\_hash\_pos}}
\item {\func{frame\_set\_abbrev\_pos}}
\item {\func{frame\_set\_abbrev\_level}}
\item {\func{frame\_set\_all\_pos}}
\item {\func{build\_rframe\_to\_req}}
\item {\func{split\_rframe\_for\_reqs}}
\item {\func{lookup\_all\_ctree\_root\_abbrevs}}
\item {\func{lookup\_frame\_ctree\_root\_abbrev}}
\item {\func{load\_root\_abbrevs\_index}}
\end{itemize}

\subsection{Supporting Transactions}

{\exc{NotSupported}}

\begin{itemize}
\item {\func{strip\_bitseq\_true}}
\item {\func{strip\_bitseq\_false}}
\item {\func{strip\_bitseq\_true0}}
\item {\func{strip\_bitseq\_false0}}
\item {\func{ctree\_lookup\_input\_assets}}
\item {\func{ctree\_supports\_tx}}
\item {\func{ctree\_supports\_tx\_2}}
\item {\func{tx\_octree\_trans}}
\item {\func{txl\_octree\_trans}}
\item {\func{full\_needed}}
\item {\func{get\_tx\_supporting\_octree}}
\item {\func{get\_txl\_supporting\_octree}}
\end{itemize}

\section{Grafting Trees}

\module{ctregraft}

{\bf{Note:}} 
In the Coq formalization the Coq module {\coqmod{CTreeGrafting}}
corresponds to {\module{ctregrafting}}.
For more information, see~\cite{White2015b}.

{\type{cgraft}}
with serialization function
{\serfunc{seo\_cgraft}}
and deerialization function
{\serfunc{sei\_cgraft}}.

\begin{itemize}
\item {\func{cgraft\_valid}}
\item {\func{ctree\_cgraft}}
\item {\func{factor\_tx\_ctree\_cgraft}}
\item {\func{factor\_inputs\_ctree\_cgraft}}
\end{itemize}
