{\bf{Warning:}} The top level code is only partially written and may possibly be rewritten completely.
The information is this chapter is subject to changes in the near future.

The file {\file{qeditas.ml}} is
used to create an executable
{\exec{qeditas}}.
This executable starts several threads for networking, staking (optionally)
and finally for a console-style interface.
The module {\module{commands}} handles commands called using the command line
interface.

\section{Main Executable}

To understand what the executable {\exec{qeditas}} does,
see the code near the end of the file {\file{qeditas.ml}}.
We describe the tasks {\exec{qeditas}} executes briefly.
The function {\func{initialize}}
is called first and is described in Section~\ref{sec:init}.
Next the function {\func{initnetwork}} is called,
see Section~\ref{sec:initnetwork}.
If the configuration variable {\var{staking}} is set to {\val{true}},
then a thread is created which calls the function {\func{stakingthread}},
see Section~\ref{sec:stakingthread}.
Finally, a main loop begins for reading and processing commands
from the console begins,
see Section~\ref{sec:mainloop}.


\subsection{Initialization}\label{sec:init}

The {\func{initialize}} function begins by checking the command line arguments for an option
of the form \verb+-datadir=...+
which would override the default data directory (usually {\dir{.qeditas}}
in the user's home directory).
It then reads the config file {\file{qeditas.conf}} in the data directory.
This may override some default values in the {\module{config}} module.
It then reads the other command line arguments which may again override
some values in the {\module{config}} module.
If the {\var{testnet}} configuration variable is {\val{true}},
then the {\dir{testnet}} subdirectory of the main data directory is used.
This implies the testnet will have its own databases, its own wallet, and so on.
The database directory is set and configured and a log file is opened.

The code then checks if either the {\var{seed}} variable in {\module{config}}
has been set to a nonempty string. (It should be a 40 character hex string.)
The current code in {\module{setconfig}} sets {\var{seed}} to
\begin{verbatim}
68324ba252550a4cb02b7279cf398b9994c0c39f
\end{verbatim}
unless it is specifically set in the configuration file or on the command line.
The value above is the last 20 bytes of the hash of Bitcoin block 378800,
and was a value included only for testing purposes.
The intention was to choose a Bitcoin block height roughly one week in the future
when the time came for Qeditas to launch. The last 20 bytes of that block hash would
be the value for {\var{seed}}. The purpose of this value is to initialize the
current stake modifier and the future stake modifier (see {\func{set\_genesis\_stakemods}}).
These stake modifiers affect which assets will stake within the first 512 blocks.
In particular it affects the genesis block (at Qeditas block height).
For the launch to be fair, these stake modifiers should not be predictable before launch.
This goal could be accomplished in other ways.
The possibility is left open in the future that {\var{seed}} is not set but
that a checkpoint has been set so that a node can begin following the block chain
from that checkpoint. (The full history is not required. Each ledger tree contains
the full information required to continue.)

If the {\var{testnet}} configuration variable is set, then the difficulty is decreased significantly
(setting {\var{genesistarget}} $2^{200}$ so that finding a hit to stake is not difficult
and setting {\var{max\_target}} $2^{230}$, practically as high as possible).

The function {\func{initblocktree}} from the {\module{net}} module
is called.\footnote{The blocktree code is not yet fully written or documented. It is intended to store the headers giving the best block chain in addition to orphaned headers.}

Next the wallet is loaded using {\func{load\_wallet}} in the {\module{commands}} module see Section~\ref{sec:commands}.

A random 64-bit nonce is obtained from {\file{/dev/urandom}} in order to prevent
the node from connecting to itself.
The variable {\var{this\_nodes\_nonce]} from the {\module{net}} module
is set to the nonce.

\subsection{Initialization of the Network}\label{sec:initnetwork}

The {\func{initnetwork}} function starts several threads to
handle connections to the network.
First, if the configuration variable {\var{ip}}
has been set to an IP-address, then
a listener socket is opened and a thread
is started to listen for incoming connections (using
the function {\func{netlistener}}).
Then the function {\func{netseeker}} is called which
loads the known peers
and calls {\func{netseeker\_loop}}.
The loop tries to connect to peers
every 10 minutes, unless the maximum number of connections has been reached.

Each time a connection is created, a thread is created for that thread
(using {\func{connlistener}} for message handling)
and the corresponding information is added to a global {\func{netconns}}.

Most of this networking code is in the {\module{net}} module, which is
currently only partially written.

\subsection{Staking}\label{sec:stakingthread}

The function {\func{stakingthread}} loops
and once a minute checks to see if
the next chances to stake have been calculated
for the current best block.
If not, {\func{compute\_staking\_chances}}
is called to compute the chances to stake
(based on the staking assets in the wallet)
for the next 1 or 2 hours.

\subsection{Main Loop}\label{sec:mainloop}

This main loop prints a prompt (see the configuration variable {\var{prompt}}),
reads a line and sends this line to {\func{do\_command}}.
If the user presses CTRL-D, the {\exc{End\_of\_file}} exception is raised
resulting in the process exiting.
The process will also exit if the user issues the command {\command{exit}}.
A command may also raise the exception {\exc{Exit}} which will be silently ignored
and the loop continues, issuing prompt and waiting for the next command.
All other exceptions are displayed to the user before the loop continues.

The supported commands are still in the process of being implemented.
The code for executing most commands is in the {\module{commands}} module
which we describe in Section~\ref{sec:commands}.
Here are a few that are currently supported:
\begin{itemize}
\item {\command{exit}} - exit qeditas.
\item {\command{printassets}} {\it{[ledger root in hex]}} - print the assets held at the addresses in the wallet in the ledger with the given root. This only prints the visible assets. Some assets will be missing if the local approximation of the compact tree does not include the assets explicitly. If the ledger root is omitted, then the ledger root of the most recent best block is used.
\item {\command{importprivkey}} - import a private key in Qeditas WIF format.
\item {\command{importbtcprivkey}} - import a private key in Bitcoin WIF format.
\item {\command{importwatchaddr}} - import a Qeditas address for watching assets, without importing the corresponding private key.
\item {\command{importwatchbtcaddr}} - import a Bitcoin address as a Qeditas address for watching assets, without importing the corresponding private key.
\item {\command{importendorsement}} - import a Bitcoin signed message to allow a Qeditas private key (held in the wallet) to sign for a corresponding Bitcoin address. This is the safe way to claim assets in the initial distribution.
\item {\command{btctoqedaddr}} - give the Qeditas address that corresponds to a given Bitcoin address.
\end{itemize}

\section{Commands}\label{sec:commands}

The module {\module{commands}} is intended to support a variety of commands a user may need.
At the moment it only supports limited wallet and transaction creation commands.
Some state information is held in this module (although it likely should be moved elsewhere).
\begin{itemize}
\item {\var{walletkeys}} contains the private keys in the wallet.
More specifically it is a list of values of the form $(k,b,(x,y),w,h,a)$
where $k$ is the private key, $b$ is a boolean indicating if it is for the compressed public key,
$(x,y)$ is the public key, $w$ is the string base-58 WIF format, $h$ is the 20-byte hash value
corresponding to the p2pkh address and $a$ is the string base-58 Qeditas p2pkh address.
\item {\var{walletp2shs}} contains entries of the form $(h,a,\overline{b})$
where $h$ is the 20-byte hash value of a p2sh address, $a$ is the base-58 Qeditas p2sh address
and $\overline{b}$ is the sequence of bytes giving the script corresponding to $h$.
Note that this does not directly give a way of ``signing'' for the p2sh address.
\item {\var{walletendorsements}} contains the endorsements in the wallet.
In particular it is a list of values of the form $(\alpha,\beta,(x,y),b,\sigma)$
where $\alpha$ and $\beta$ are pay addresses,\footnote{Actually, in what is implemented we assume they are both p2pkh addresses. In principle endorsements involving p2sh addresses are supported by the code in {\module{sigant}} and {\module{script}}, but support has not been implemented in {\module{commands}}.}
$(x,y)$ is the public key for $\alpha$,
$b$ is a boolean indicating if $\alpha$ is the address for the compressed public key
and $\sigma$ is a signature for a
Bitcoin message of the form ``endorse $\beta$''
(or ``testnet:endorse $\beta$'' in the testnet)
signed with the private key for $\alpha$.
The private key for $\beta$ should be in {\var{walletkeys}}
and this private key along with the endorsement means the wallet can sign for $\alpha$.\footnote{The endorsement mechanism gives Bitcoin users a way to claim their part of the initial distribution without revealing their private keys.}
\item {\var{walletwatchaddrs}}
contains addresses to ``watch.'' 
\item {\var{stakingassets}}
contains a list of assets which the node can stake.
\item {\var{storagetrmassets}}
is intended contain a list of assets at term addresses which the node can use as proof-of-storage to improve the chances of staking.
Currently it is unused.
\item {\var{storagedocassets}}
is intended to contain a list of documents at publication assets which the node can use as proof-of-storage to improve the chances of staking.
Currently it is unused.
\item {\var{recenttxs}} is a hash table associating hash values (transaction ids)
with signed transactions. This is loaded and saved to the file {\file{recenttxs}}.
The intention is that this holds transactions which have been created but
are not yet published (and may only be partially signed).
\item {\var{txpool}} is a hash table associating hash values (transaction ids)
with signed transactions. This is loaded and saved to the file {\file{txpool}}.
The intention is that this holds transactions which have been published
but are not yet included in a block.
\end{itemize}

The following functions are for loading and saving the state in certain files.
\begin{itemize} % todo: update this to correspond to the current state of commands
\item {\func{load\_recenttxs}} sets {\var{recenttxs}} by loading the contents fo {\file{recenttxs}}.
\item {\func{load\_txpool}} sets {\var{txpool}} by loading the contents fo {\file{txpool}}.
\item {\func{load\_wallet}} sets {\var{walletkeys}}, {\var{walletp2shs}},
{\var{walletendorsements}}
and {\var{walletwatchaddrs}}
by loading the file {\file{wallet}}.
\item {\func{save\_wallet}} saves the current wallet contents
(the values of {\var{walletkeys}}, {\var{walletp2shs}},
{\var{walletendorsements}}
and {\var{walletwatchaddrs}})
in {\file{wallet}}.
\item {\func{printassets}} prints the assets from the current ledger tree at the addresses
mentioned in the wallet.
\item {\func{btctoqedaddr}} parses a Bitcoin address (base-58 representation) and prints the corresponding Qeditas address (base-58 representation).
\item {\func{importprivkey}} imports a private key given in Qeditas WIF.
\item {\func{importbtcprivkey}} imports a private key given in Bitcoin WIF.
\item {\func{importendorsement}} imports an endorsement.
\item {\func{importwatchaddr}} imports a Qeditas address to watch.
\item {\func{importwatchbtcaddr}} imports a Bitcoin address in order to watch the corresponding Qeditas address.
\end{itemize}

